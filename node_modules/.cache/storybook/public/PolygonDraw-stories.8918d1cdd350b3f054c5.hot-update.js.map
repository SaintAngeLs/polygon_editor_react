{"version":3,"file":"PolygonDraw-stories.8918d1cdd350b3f054c5.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAIA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAgEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AAIA;AAEA;AAGA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAMA;AAAA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AAAA;AAEA;AACA;AAAA;AACA;AAKA;AAAA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AA3rBA;AA6rBA","sources":["webpack://@freenow/react-polygon-editor/./src/PolygonDraw/Map.tsx"],"sourcesContent":["import React, { memo } from 'react';\nimport { LatLng, latLngBounds, LatLngBounds, LatLngTuple, LeafletMouseEvent } from 'leaflet';\nimport { useMap, Pane, Polyline, Rectangle } from 'react-leaflet';\nimport flatten from 'lodash.flatten';\n\nimport { Coordinate } from 'types';\n\nimport {\n    createCoordinateFromLeafletLatLng,\n    createLeafletLatLngBoundsFromCoordinates,\n    createLeafletLatLngFromCoordinate,\n    addCoordinates,\n    subtractCoordinates,\n    getPolygonEdges,\n    isCoordinateInPolygon,\n    isPolygonClosed,\n    getMidPoint,\n} from '../helpers';\nimport { Modal } from '../common/components/Modal';\nimport { ExportPolygonForm } from '../conversion/ExportPolygonForm';\nimport { ImportPolygonForm } from '../conversion/ImportPolygonForm';\n//import { TileLayer } from '../leaflet/TileLayer';\nimport { MAP } from '../constants';\nimport { Map, Container } from '../leaflet/Map';\nimport { ActionBar } from '../ActionBar/ActionBar';\nimport { EdgeVertex } from './EdgeVertex';\nimport { PolygonVertex } from './PolygonVertex';\nimport { BoundaryPolygon } from './BoundaryPolygon';\nimport { Polygon } from './Polygon';\nimport MapInner from './MapInner';\nimport { EdgeConstraintsBar } from '../ActionBar/EdgeConstraintsBar';\nimport { IconForHorizontal } from '../ActionBar/Icons/IconForHorizontal';\nimport { IconForVertical } from '../ActionBar/Icons/IconForVertical';\n\ninterface MapSnapshot {\n    reframe: boolean;\n    size: string;\n}\n\nexport interface Props {\n    /**\n     * activePolygonIndex is the index of the polygon that is currently available for editing\n     */\n    activePolygonIndex: number;\n    highlightedPolygonIndex?: number;\n    polygonCoordinates: Coordinate[][];\n    boundaryPolygonCoordinates: Coordinate[];\n    selection: Set<number>;\n    editable: boolean;\n    drawable: boolean;\n    initialCenter: LatLngTuple;\n    initialZoom: number;\n    isPolygonClosed: boolean;\n    onClick?: (index: number) => void;\n    onMouseEnter?: (index: number) => void;\n    onMouseLeave?: (index: number) => void;\n    addPoint: (coord: Coordinate) => void;\n    setEdgeRestriction: (restriction: EdgeRestriction) => void;\n    addPointToEdge: (coordinate: Coordinate, index: number) => void;\n    deselectAllPoints: () => void;\n    removePointFromSelection: (index: number) => void;\n    addPointsToSelection: (indices: number[]) => void;\n    selectPoints: (indices: number[]) => void;\n    moveSelectedPoints: (newPosition: Coordinate) => void;\n    deletePolygonPoints: () => void;\n    selectAllPoints: () => void;\n    setPolygon: (polygon: Coordinate[]) => void;\n    onUndo: () => void;\n    onRedo: () => void;\n}\n\ntype MapType = ReturnType<typeof useMap>;\n\nexport interface State {\n    isMovedPointInBoundary: boolean;\n    isShiftPressed: boolean;\n    isMoveActive: boolean;\n    rectangleSelection: {\n        startPosition: Coordinate;\n        endPosition: Coordinate;\n        startTime: number;\n    } | null;\n    selectedEdge:number | null;\n    edgeRelationships: string[], \n    previousMouseMovePosition?: Coordinate;\n    edgeRestrictions: EdgeRestriction;\n    isPenToolActive: boolean;\n    isDrawToolActive: boolean;\n    newPointPosition: Coordinate | null;\n    showExportPolygonModal: boolean;\n    showImportPolygonModal: boolean;\n}\n\nexport type EdgeRestriction = 'horizontal' | 'vertical' | 'none' | null;\n\n\nexport class BaseMap extends React.Component<Props, State> {\n    private map: MapType | null = null;\n\n    state: State = {\n        isMovedPointInBoundary: true,\n        isShiftPressed: false,\n        isMoveActive: false,\n        rectangleSelection: null,\n        previousMouseMovePosition: undefined,\n        selectedEdge: null,\n        edgeRestrictions: null,\n        edgeRelationships: [], \n        isPenToolActive: false,\n        isDrawToolActive: false,\n        newPointPosition: null,\n        showExportPolygonModal: false,\n        showImportPolygonModal: false,\n    };\n\n    static getDerivedStateFromProps(props: Props, state: State): State {\n        return {\n            ...state,\n            isPenToolActive: props.polygonCoordinates.length === 0 ? true : state.isPenToolActive,\n            isDrawToolActive: props.polygonCoordinates.length === 0 ? false : state.isDrawToolActive,\n        };\n    }\n\n    componentDidMount() {\n        this.reframe();\n        this.toggleVectorMode();\n\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.addEventListener('keydown', this.handleKeyDown, false);\n            container.addEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    componentWillUnmount() {\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.removeEventListener('keydown', this.handleKeyDown, false);\n            container.removeEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    getSnapshotBeforeUpdate(prevProps: Props, prevState: State): MapSnapshot {\n        const reframe =\n            // Reframe when the polygon loads for the first time\n            (prevProps.polygonCoordinates[prevProps.activePolygonIndex].length === 0 &&\n                this.props.polygonCoordinates[this.props.activePolygonIndex].length > 1) ||\n            // Reframe when the boundary polygon loads for the first time\n            prevProps.boundaryPolygonCoordinates !== this.props.boundaryPolygonCoordinates;\n\n        const size = this.getSize(this.map);\n\n        return { reframe, size };\n    }\n\n    componentDidUpdate(prevProps: Readonly<Props>, prevState: Readonly<State>, { reframe, size }: MapSnapshot): void {\n        if (reframe) {\n            this.reframe();\n        }\n\n        if (this.map && this.getSize(this.map) !== size) {\n            this.map.invalidateSize();\n        }\n    }\n\n    setMap = (map: MapType) => {\n        if (map) {\n            this.map = map;\n\n            this.reframe();\n            this.toggleVectorMode();\n\n            const container = map?.getContainer();\n\n            if (container) {\n                container?.addEventListener('keydown', this.handleKeyDown, false);\n                container?.addEventListener('keyup', this.handleKeyUp);\n            }\n        }\n    };\n\n    reframe = () => {\n        const { polygonCoordinates, boundaryPolygonCoordinates, initialCenter, initialZoom } = this.props;\n\n        if (polygonCoordinates[this.props.activePolygonIndex].length > 1) {\n            this.reframeOnPolygon(polygonCoordinates);\n        } else if (boundaryPolygonCoordinates.length > 0 && boundaryPolygonCoordinates !== MAP.WORLD_COORDINATES) {\n            this.reframeOnPolygon(boundaryPolygonCoordinates);\n        } else if (this.map) {\n            this.map.setView(initialCenter, initialZoom);\n        }\n    };\n\n    reframeOnPolygon = (polygonCoordinates: Coordinate[] | Coordinate[][]) => {\n        if (this.map && polygonCoordinates.length > 0) {\n            const bounds = createLeafletLatLngBoundsFromCoordinates(flatten(polygonCoordinates));\n\n            this.map.fitBounds(bounds);\n        }\n    };\n\n    toggleVectorMode = () => {\n        if (!this.props.editable) {\n            return;\n        }\n        this.setState({\n            isPenToolActive: !this.state.isPenToolActive,\n            isDrawToolActive: false, // Ensure the \"draw\" tool is deactivated when switching to the \"pen\" tool\n            newPointPosition: null,\n        });\n    };\n\n    toggleDrawMode = () => {\n        if (!this.props.drawable) {\n            return;\n        }\n        this.setState({\n            isDrawToolActive: !this.state.isDrawToolActive,\n            //isPenToolActive: false, // Ensure the \"pen\" tool is deactivated when switching to the \"draw\" tool\n            newPointPosition: null,\n        });\n    };\n\n    getSize = (map: MapType | null): string => {\n        const container = map?.getContainer();\n        return container ? `${container.clientHeight}x${container.clientWidth}` : '';\n    };\n\n    handleOnFocusClicked = () => {\n        const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        if (activePolygon) {\n            this.reframeOnPolygon(activePolygon);\n        } else {\n            this.reframe();\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Export / Import methods                      //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleExportPolygon = (serialized: string) => {\n        navigator.clipboard.writeText(serialized);\n    };\n\n    handleExportPolygonActionClicked = () => {\n        this.setState({ showExportPolygonModal: true });\n    };\n\n    handleExportPolygonModalClosed = () => {\n        this.setState({ showExportPolygonModal: false });\n    };\n\n    handleImportPolygon = (coordinates: Coordinate[]) => {\n        this.props.setPolygon(coordinates);\n        this.reframeOnPolygon(coordinates);\n    };\n\n    handleImportPolygonActionClicked = () => {\n        this.setState({ showImportPolygonModal: true });\n    };\n\n    handleImportPolygonModalClosed = () => {\n        this.setState({ showImportPolygonModal: false });\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Map Events methods                           //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleMapClick = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (\n            this.state.isPenToolActive &&\n            !this.props.isPolygonClosed &&\n            isCoordinateInPolygon(coordinate, this.props.boundaryPolygonCoordinates)\n        ) {\n            this.props.addPoint(coordinate);\n        } else if (!this.state.isShiftPressed) {\n            this.props.deselectAllPoints();\n        }\n    };\n\n    handleMouseDownOnMap = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n\n        if (this.state.isShiftPressed) {\n            this.setState({\n                rectangleSelection: {\n                    startPosition: coordinate,\n                    endPosition: coordinate,\n                    startTime: new Date().getTime(),\n                },\n            });\n        }\n    };\n\n    handleMouseUpOnMap = () => {\n        if (this.state.rectangleSelection) {\n            this.setState({\n                rectangleSelection: null,\n            });\n        }\n    };\n\n    handleMouseMoveOnMap = (event: LeafletMouseEvent) => {\n        const mouseCoordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (this.state.rectangleSelection && new Date().getTime() - this.state.rectangleSelection?.startTime >= 100) {\n            const start = this.state.rectangleSelection.startPosition;\n            if (start) {\n                const bounds: LatLngBounds = latLngBounds(createLeafletLatLngFromCoordinate(start), event.latlng);\n\n                const activePolygon: Coordinate[] | undefined =\n                    this.props.polygonCoordinates[this.props.activePolygonIndex];\n                if (activePolygon) {\n                    const pointsInsideBounds: number[] = [];\n                    activePolygon.forEach((point, index) => {\n                        if (bounds.contains(createLeafletLatLngFromCoordinate(point))) {\n                            pointsInsideBounds.push(index);\n                        }\n                    });\n                    this.props.selectPoints(pointsInsideBounds);\n                }\n            }\n            this.setState({\n                rectangleSelection: {\n                    ...this.state.rectangleSelection,\n                    endPosition: mouseCoordinate,\n                },\n            });\n        } else {\n            const newPointPosition =\n                this.state.isPenToolActive &&\n                !this.props.isPolygonClosed &&\n                isCoordinateInPolygon(mouseCoordinate, this.props.boundaryPolygonCoordinates)\n                    ? mouseCoordinate\n                    : null;\n\n            this.setState({ newPointPosition });\n        }\n    };\n\n    handleMouseOutOfMap = () =>\n        this.setState({\n            newPointPosition: null,\n            rectangleSelection: null,\n        });\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Vertex methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    onPolygonVertexClick = (index: number) => {\n        if (\n            index === 0 &&\n            this.props.polygonCoordinates[this.props.activePolygonIndex].length > 2 &&\n            !this.props.isPolygonClosed\n        ) {\n            // Close polygon when user clicks the first point\n            this.props.addPoint({ ...this.props.polygonCoordinates[this.props.activePolygonIndex][0] });\n        } else if (this.state.isShiftPressed) {\n            if (this.props.selection.has(index)) {\n                this.props.removePointFromSelection(index);\n            } else {\n                this.props.addPointsToSelection([index]);\n            }\n        } else {\n            this.props.selectPoints([index]);\n        }\n    };\n\n    startVertexMove = (latLng: LatLng) => {\n        if (!this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: true,\n                previousMouseMovePosition: createCoordinateFromLeafletLatLng(latLng),\n            });\n        }\n    };\n\n    onPolygonVertexDragStart = (latLng: LatLng, index: number) => {\n        if (!this.props.selection.has(index)) {\n            if (this.state.isShiftPressed) {\n                this.props.addPointsToSelection([index]);\n            } else {\n                this.props.selectPoints([index]);\n            }\n        }\n        this.startVertexMove(latLng);\n    };\n\n    updateVertexPosition = (latLng: LatLng) => {\n        if (this.state.isMoveActive && this.state.previousMouseMovePosition) {\n            const coordinate: Coordinate = createCoordinateFromLeafletLatLng(latLng);\n            const moveVector = subtractCoordinates(coordinate, this.state.previousMouseMovePosition);\n\n            const nextCoordinates = Array.from(this.props.selection)\n                .map((i) => this.props.polygonCoordinates[this.props.activePolygonIndex][i])\n                .map((coord) => addCoordinates(coord, moveVector));\n\n            const inBoundary = nextCoordinates.every((nextCoordinate) =>\n                isCoordinateInPolygon(nextCoordinate, this.props.boundaryPolygonCoordinates)\n            );\n\n            if (inBoundary) {\n                this.props.moveSelectedPoints(moveVector);\n                this.setState({ previousMouseMovePosition: coordinate, isMovedPointInBoundary: true });\n            } else {\n                this.setState({ isMovedPointInBoundary: false });\n            }\n        }\n\n        \n    };\n\n    endVertexMove = () => {\n        if (this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: false,\n                previousMouseMovePosition: undefined,\n                isMovedPointInBoundary: true,\n            });\n        }\n    };\n\n    handleEdgeClick = (coordinate: Coordinate, index: number) => {\n        if (this.state.selectedEdge === index) {\n            // If the same edge is clicked, add a vertex in the middle of the edge.\n            this.handleAddVertexInMiddleOfEdge();\n        } else {\n            // Otherwise, just set the clicked edge as the selected edge.\n            this.setState({ selectedEdge: index });\n        }\n    };\n\n    \n    \n\n    handleAddVertexInMiddleOfEdge = () => {\n        if (this.state.selectedEdge === null) {\n            console.error(\"No edge selected to add a vertex.\");\n            return;\n        }\n    \n        const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        const startPoint = activePolygon[this.state.selectedEdge];\n        const endPoint = activePolygon[(this.state.selectedEdge + 1) % activePolygon.length];\n        // const midpoint = getMidPoint(startPoint, endPoint);\n    \n        // this.props.addPointToEdge(midpoint, this.state.selectedEdge);\n        // this.setState({\n        //     selectedEdge: null\n        // });\n\n        let midpoint;\n\n        // if (this.state.edgeRestrictions === 'horizontal') {\n        //     midpoint = {\n        //         latitude: (startPoint.latitude + endPoint.latitude) / 2,\n        //         longitude: startPoint.longitude  // Keeps the longitude unchanged to ensure a horizontal edge.\n        //     };\n        // } else if (this.state.edgeRestrictions === 'vertical') {\n        //     midpoint = {\n        //         latitude: startPoint.latitude,  // Keeps the latitude unchanged to ensure a vertical edge.\n        //         longitude: (startPoint.longitude + endPoint.longitude) / 2\n        //     };\n        // } else {\n        //     midpoint = getMidPoint(startPoint, endPoint);  // Assuming getMidPoint() returns a Coordinate object with latitude and longitude.\n        // }\n\n\n        if (this.state.edgeRelationships[this.state.selectedEdge] === 'horizontal') {\n            midpoint = {\n                latitude: (startPoint.latitude + endPoint.latitude) / 2,\n                longitude: startPoint.longitude, // Keeps the longitude unchanged to ensure a horizontal edge.\n            };\n        } else if (this.state.edgeRelationships[this.state.selectedEdge] === 'vertical') {\n            midpoint = {\n                latitude: startPoint.latitude, // Keeps the latitude unchanged to ensure a vertical edge.\n                longitude: (startPoint.longitude + endPoint.longitude) / 2,\n            };\n        } else {\n            midpoint = getMidPoint(startPoint, endPoint); // Calculate the midpoint using your existing logic.\n        }\n    \n        this.props.addPointToEdge(midpoint, this.state.selectedEdge);\n\n        this.setState({\n            selectedEdge: null\n        });\n    };\n\n    setEdgeRelationship = (relationshipType: string) => {\n        if (this.state.selectedEdge !== null) {\n            const updatedEdgeRelationships = [...this.state.edgeRelationships];\n            updatedEdgeRelationships[this.state.selectedEdge] = relationshipType;\n            this.setState({ edgeRelationships: updatedEdgeRelationships });\n        }\n    };\n\n    handleSetHorizontal = () => {\n        this.setState({ edgeRestrictions: 'horizontal' }, () => {\n            // Call the function to set the edge restriction in the parent component\n            this.props.setEdgeRestriction('horizontal');\n            this.setEdgeRelationship('horizontal');\n            \n        });\n        this.setState({ edgeRelationships: ['horizontal'] });\n        // Call the function to set the edge restriction in the parent component\n        this.props.setEdgeRestriction('horizontal');\n    }\n    \n    handleSetVertical = () => {\n        this.setState({ edgeRestrictions: 'vertical' }, () => {\n            // Call the function to set the edge restriction in the parent component\n            this.props.setEdgeRestriction('vertical');\n            this.setEdgeRelationship('vertical');\n        });\n        this.setState({ edgeRelationships: ['vertical'] });\n    // Call the function to set the edge restriction in the parent component\n        this.props.setEdgeRestriction('vertical');\n    }\n\n    \n    ///////////////////////////////////////////////////////////////////////////\n    //                      Keyboard handling methods                        //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleKeyDown = (e: KeyboardEvent) => {\n        e.preventDefault();\n        switch (e.key) {\n            case 'Escape':\n                this.props.deselectAllPoints();\n                break;\n            case 'Backspace':\n                this.props.deletePolygonPoints();\n                break;\n            case 'Shift':\n                this.setState({ isShiftPressed: true });\n                break;\n            case 'p':\n                this.toggleVectorMode();\n                break;\n            case 'd':\n                if (this.props.editable) {\n                    this.props.deselectAllPoints();\n                }\n                break;\n            case 'a':\n                if (this.props.editable) {\n                    this.props.selectAllPoints();\n                }\n                break;\n            case 'f':\n                this.reframe();\n                break;\n            case 'z':\n                if (e.metaKey && e.shiftKey) {\n                    this.props.onRedo();\n                } else if (e.metaKey) {\n                    this.props.onUndo();\n                }\n                break;\n        }\n    };\n\n    handleKeyUp = (e: KeyboardEvent) => {\n        switch (e.key) {\n            case 'Shift':\n                this.setState({ isShiftPressed: false });\n                break;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Render methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    renderPolygonVertex = (coordinate: Coordinate, index: number) => {\n        return (\n            <PolygonVertex\n                coordinate={coordinate}\n                isSelected={this.props.selection.has(index)}\n                key={index}\n                index={index}\n                onClick={this.onPolygonVertexClick}\n                onDragStart={this.onPolygonVertexDragStart}\n                onDrag={this.updateVertexPosition}\n                onDragEnd={this.endVertexMove}\n            />\n        );\n    };\n\n    renderActivePolygonPoints = () => {\n        return this.props.polygonCoordinates[this.props.activePolygonIndex].map(this.renderPolygonVertex);\n    };\n\n    renderVertexEdge = (coordinate: Coordinate, index: number) => (\n        <EdgeVertex \n            key={index} \n                index={index} \n                coordinate={coordinate} \n                onClick={this.props.addPointToEdge} \n                edgeRestriction={this.state.edgeRestrictions}\n            />\n    );\n    // the olde version with not fincvtionalitu to work with the adding the vertexe to the middle of the\n    // renderPolygonEdges = () => {\n    //     return getPolygonEdges(this.props.polygonCoordinates[this.props.activePolygonIndex]).map(this.renderVertexEdge);\n    // };\n\n    // the new wersion of the renderVertexEdge\n    renderPolygonEdges = () => {\n        return getPolygonEdges(this.props.polygonCoordinates[this.props.activePolygonIndex]).map((coordinate, index) => (\n            <EdgeVertex\n                key={index}\n                index={index}\n                coordinate={coordinate}\n                onClick={this.handleEdgeClick}\n                edgeRestriction={this.state.edgeRestrictions} \n            >\n                {this.state.selectedEdge === index && (\n                    <div>\n                        Relationship: {this.state.edgeRelationships[index]}\n                        {/* Render icons here based on the relationship type */}\n                        {this.state.edgeRelationships[index] === 'horizontal' && <IconForHorizontal />}\n                        {this.state.edgeRelationships[index] === 'vertical' && <IconForVertical />}\n                    </div>\n                )}\n            </EdgeVertex>\n        ));\n    };\n    \n    \n\n\n    renderInactivePolygons = () => {\n        const activePolygonIsClosed = isPolygonClosed(this.props.polygonCoordinates[this.props.activePolygonIndex]);\n\n        return this.props.polygonCoordinates.map((coordinates, index) => {\n            const eventHandler = {\n                onClick: () => this.props.onClick && this.props.onClick(index),\n                onMouseEnter: () => this.props.onMouseEnter && this.props.onMouseEnter(index),\n                onMouseLeave: () => this.props.onMouseLeave && this.props.onMouseLeave(index),\n            };\n\n            return index === this.props.activePolygonIndex ? null : (\n                <Polygon\n                    key={`${index}-${coordinates.reduce((acc, cur) => acc + cur.latitude + cur.longitude, 0)}`}\n                    coordinates={coordinates}\n                    isActive={false}\n                    isHighlighted={index === this.props.highlightedPolygonIndex}\n                    {...(activePolygonIsClosed ? eventHandler : {})}\n                />\n            );\n        });\n    };\n\n    renderActivePolygon = () => {\n        const coordinates = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        const index = this.props.activePolygonIndex;\n        return (\n            <Polygon\n                coordinates={coordinates}\n                isActive\n                isHighlighted={false}\n                onClick={() => this.props.onClick && this.props.onClick(index)}\n                onMouseEnter={() => this.props.onMouseEnter && this.props.onMouseEnter(index)}\n                onMouseLeave={() => this.props.onMouseLeave && this.props.onMouseLeave(index)}\n            />\n        );\n    };\n\n    renderPolyline = () => {\n        const { newPointPosition } = this.state;\n        const polygon = this.props.polygonCoordinates[this.props.activePolygonIndex].map(\n            createLeafletLatLngFromCoordinate\n        );\n\n        if (polygon.length === 0) {\n            return null;\n        }\n\n        const newPath = [polygon[polygon.length - 1]];\n        if (newPointPosition) {\n            newPath.push(createLeafletLatLngFromCoordinate(newPointPosition));\n        }\n\n        return (\n            <>\n                <Polyline positions={polygon} color={MAP.POLYGON_ACTIVE_COLOR} interactive={false} />\n                <Polyline positions={newPath} color={MAP.POLYGON_ACTIVE_COLOR} dashArray=\"2 12\" interactive={false} />\n            </>\n        );\n    };\n\n    renderSelectionRectangle = () => {\n        if (this.state.rectangleSelection) {\n            const bounds: LatLngBounds = latLngBounds(\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.startPosition),\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.endPosition)\n            );\n\n            return (\n                <Rectangle\n                    color={MAP.RECTANGLE_SELECTION_COLOR}\n                    fillColor={MAP.RECTANGLE_SELECTION_COLOR}\n                    bounds={bounds}\n                />\n            );\n        }\n        return null;\n    };\n\n    render() {\n        const { editable,  drawable, selection, initialZoom, initialCenter } = this.props;\n        const { newPointPosition, isPenToolActive, isDrawToolActive } = this.state;\n\n        return (\n            <Container>\n                <Map\n                    fadeAnimation\n                    trackResize\n                    zoomControl={false}\n                    ref={this.setMap}\n                    center={initialCenter}\n                    zoom={initialZoom}\n                    zoomDelta={2}\n                    zoomSnap={1.5}\n                    boxZoom={false}\n                    drawCursor={!!newPointPosition}\n                >\n                    <BoundaryPolygon\n                        coordinates={this.props.boundaryPolygonCoordinates}\n                        hasError={!this.state.isMovedPointInBoundary}\n                    />\n                    {this.props.isPolygonClosed ? this.renderActivePolygon() : this.renderPolyline()}\n                    {this.renderInactivePolygons()}\n\n                    {editable && (\n                        <Pane name=\"Polygon points\">\n                            {this.renderActivePolygonPoints()}\n                            {this.props.isPolygonClosed && isPenToolActive && this.renderPolygonEdges()}\n                        </Pane>\n                    )}\n\n                    {this.state.rectangleSelection && this.renderSelectionRectangle()}\n\n                    {/* <TileLayer /> */}\n                    <MapInner\n                        onClick={this.handleMapClick}\n                        onMouseOut={this.handleMouseOutOfMap}\n                        onMouseMove={this.handleMouseMoveOnMap}\n                        onMouseDown={this.handleMouseDownOnMap}\n                        onMouseUp={this.handleMouseUpOnMap}\n                    />\n                </Map>\n                <ActionBar\n                    editable={editable}\n                    drawable={drawable}\n                    isVectorModeEnabled={isPenToolActive}\n                    isDrawModeEnabled={isDrawToolActive}\n                    onDelete={this.props.deletePolygonPoints}\n                    onFocus={this.handleOnFocusClicked}\n                    onAddVertex={this.handleAddVertexInMiddleOfEdge}\n                    onEnableDrawMode={this.toggleDrawMode}\n                    onEnableVectorMode={this.toggleVectorMode}\n                    deleteInactive={selection.size === 0}\n                    onExport={this.handleExportPolygonActionClicked}\n                    onImport={this.handleImportPolygonActionClicked}\n                />\n                 <EdgeConstraintsBar \n                    onSetHorizontal={this.handleSetHorizontal} \n                    onSetVertical={this.handleSetVertical} \n                />\n\n                {this.state.showExportPolygonModal && (\n                    <Modal onClose={this.handleExportPolygonModalClosed}>\n                        <ExportPolygonForm\n                            polygon={this.props.polygonCoordinates[this.props.activePolygonIndex]}\n                            onSubmit={this.handleExportPolygon}\n                        />\n                    </Modal>\n                )}\n\n                {this.state.showImportPolygonModal && (\n                    <Modal onClose={this.handleImportPolygonModalClosed}>\n                        <ImportPolygonForm onSubmit={this.handleImportPolygon} />\n                    </Modal>\n                )}\n            </Container>\n        );\n    }\n}\n\nexport default memo(BaseMap);\n"],"names":[],"sourceRoot":""}