{"version":3,"file":"PolygonDraw-stories.dc74886a6d4de01447e2.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAIA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAwDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAMA;AAAA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAEA;AACA;AAAA;AACA;AAKA;AAAA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AA/hBA;AAiiBA","sources":["webpack://@freenow/react-polygon-editor/./src/PolygonDraw/Map.tsx"],"sourcesContent":["import React, { memo } from 'react';\nimport { LatLng, latLngBounds, LatLngBounds, LatLngTuple, LeafletMouseEvent } from 'leaflet';\nimport { useMap, Pane, Polyline, Rectangle } from 'react-leaflet';\nimport flatten from 'lodash.flatten';\n\nimport { Coordinate } from 'types';\n\nimport {\n    createCoordinateFromLeafletLatLng,\n    createLeafletLatLngBoundsFromCoordinates,\n    createLeafletLatLngFromCoordinate,\n    addCoordinates,\n    subtractCoordinates,\n    getPolygonEdges,\n    isCoordinateInPolygon,\n    isPolygonClosed,\n} from '../helpers';\nimport { Modal } from '../common/components/Modal';\nimport { ExportPolygonForm } from '../conversion/ExportPolygonForm';\nimport { ImportPolygonForm } from '../conversion/ImportPolygonForm';\n//import { TileLayer } from '../leaflet/TileLayer';\nimport { MAP } from '../constants';\nimport { Map, Container } from '../leaflet/Map';\nimport { ActionBar } from '../ActionBar/ActionBar';\nimport { EdgeVertex } from './EdgeVertex';\nimport { PolygonVertex } from './PolygonVertex';\nimport { BoundaryPolygon } from './BoundaryPolygon';\nimport { Polygon } from './Polygon';\nimport MapInner from './MapInner';\n\ninterface MapSnapshot {\n    reframe: boolean;\n    size: string;\n}\n\nexport interface Props {\n    /**\n     * activePolygonIndex is the index of the polygon that is currently available for editing\n     */\n    activePolygonIndex: number;\n    highlightedPolygonIndex?: number;\n    polygonCoordinates: Coordinate[][];\n    boundaryPolygonCoordinates: Coordinate[];\n    selection: Set<number>;\n    editable: boolean;\n    drawable: boolean;\n    initialCenter: LatLngTuple;\n    initialZoom: number;\n    isPolygonClosed: boolean;\n    onClick?: (index: number) => void;\n    onMouseEnter?: (index: number) => void;\n    onMouseLeave?: (index: number) => void;\n    addPoint: (coord: Coordinate) => void;\n    addPointToEdge: (coordinate: Coordinate, index: number) => void;\n    deselectAllPoints: () => void;\n    removePointFromSelection: (index: number) => void;\n    addPointsToSelection: (indices: number[]) => void;\n    selectPoints: (indices: number[]) => void;\n    moveSelectedPoints: (newPosition: Coordinate) => void;\n    deletePolygonPoints: () => void;\n    selectAllPoints: () => void;\n    setPolygon: (polygon: Coordinate[]) => void;\n    onUndo: () => void;\n    onRedo: () => void;\n}\n\ntype MapType = ReturnType<typeof useMap>;\n\nexport interface State {\n    isMovedPointInBoundary: boolean;\n    isShiftPressed: boolean;\n    isMoveActive: boolean;\n    rectangleSelection: {\n        startPosition: Coordinate;\n        endPosition: Coordinate;\n        startTime: number;\n    } | null;\n    previousMouseMovePosition?: Coordinate;\n    isPenToolActive: boolean;\n    newPointPosition: Coordinate | null;\n    showExportPolygonModal: boolean;\n    showImportPolygonModal: boolean;\n}\n\nexport class BaseMap extends React.Component<Props, State> {\n    private map: MapType | null = null;\n\n    state: State = {\n        isMovedPointInBoundary: true,\n        isShiftPressed: false,\n        isMoveActive: false,\n        rectangleSelection: null,\n        previousMouseMovePosition: undefined,\n        isPenToolActive: false,\n        newPointPosition: null,\n        showExportPolygonModal: false,\n        showImportPolygonModal: false,\n    };\n\n    static getDerivedStateFromProps(props: Props, state: State): State {\n        return {\n            ...state,\n            isPenToolActive: props.polygonCoordinates.length === 0 ? true : state.isPenToolActive,\n        };\n    }\n\n    componentDidMount() {\n        this.reframe();\n        this.toggleVectorMode();\n\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.addEventListener('keydown', this.handleKeyDown, false);\n            container.addEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    componentWillUnmount() {\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.removeEventListener('keydown', this.handleKeyDown, false);\n            container.removeEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    getSnapshotBeforeUpdate(prevProps: Props, prevState: State): MapSnapshot {\n        const reframe =\n            // Reframe when the polygon loads for the first time\n            (prevProps.polygonCoordinates[prevProps.activePolygonIndex].length === 0 &&\n                this.props.polygonCoordinates[this.props.activePolygonIndex].length > 1) ||\n            // Reframe when the boundary polygon loads for the first time\n            prevProps.boundaryPolygonCoordinates !== this.props.boundaryPolygonCoordinates;\n\n        const size = this.getSize(this.map);\n\n        return { reframe, size };\n    }\n\n    componentDidUpdate(prevProps: Readonly<Props>, prevState: Readonly<State>, { reframe, size }: MapSnapshot): void {\n        if (reframe) {\n            this.reframe();\n        }\n\n        if (this.map && this.getSize(this.map) !== size) {\n            this.map.invalidateSize();\n        }\n    }\n\n    setMap = (map: MapType) => {\n        if (map) {\n            this.map = map;\n\n            this.reframe();\n            this.toggleVectorMode();\n\n            const container = map?.getContainer();\n\n            if (container) {\n                container?.addEventListener('keydown', this.handleKeyDown, false);\n                container?.addEventListener('keyup', this.handleKeyUp);\n            }\n        }\n    };\n\n    reframe = () => {\n        const { polygonCoordinates, boundaryPolygonCoordinates, initialCenter, initialZoom } = this.props;\n\n        if (polygonCoordinates[this.props.activePolygonIndex].length > 1) {\n            this.reframeOnPolygon(polygonCoordinates);\n        } else if (boundaryPolygonCoordinates.length > 0 && boundaryPolygonCoordinates !== MAP.WORLD_COORDINATES) {\n            this.reframeOnPolygon(boundaryPolygonCoordinates);\n        } else if (this.map) {\n            this.map.setView(initialCenter, initialZoom);\n        }\n    };\n\n    reframeOnPolygon = (polygonCoordinates: Coordinate[] | Coordinate[][]) => {\n        if (this.map && polygonCoordinates.length > 0) {\n            const bounds = createLeafletLatLngBoundsFromCoordinates(flatten(polygonCoordinates));\n\n            this.map.fitBounds(bounds);\n        }\n    };\n\n    toggleVectorMode = () => {\n        if (!this.props.editable) {\n            return;\n        }\n        this.setState({\n            isPenToolActive: !this.state.isPenToolActive,\n            newPointPosition: null,\n        });\n    };\n\n    getSize = (map: MapType | null): string => {\n        const container = map?.getContainer();\n        return container ? `${container.clientHeight}x${container.clientWidth}` : '';\n    };\n\n    handleOnFocusClicked = () => {\n        const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        if (activePolygon) {\n            this.reframeOnPolygon(activePolygon);\n        } else {\n            this.reframe();\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Export / Import methods                      //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleExportPolygon = (serialized: string) => {\n        navigator.clipboard.writeText(serialized);\n    };\n\n    handleExportPolygonActionClicked = () => {\n        this.setState({ showExportPolygonModal: true });\n    };\n\n    handleExportPolygonModalClosed = () => {\n        this.setState({ showExportPolygonModal: false });\n    };\n\n    handleImportPolygon = (coordinates: Coordinate[]) => {\n        this.props.setPolygon(coordinates);\n        this.reframeOnPolygon(coordinates);\n    };\n\n    handleImportPolygonActionClicked = () => {\n        this.setState({ showImportPolygonModal: true });\n    };\n\n    handleImportPolygonModalClosed = () => {\n        this.setState({ showImportPolygonModal: false });\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Map Events methods                           //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleMapClick = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (\n            this.state.isPenToolActive &&\n            !this.props.isPolygonClosed &&\n            isCoordinateInPolygon(coordinate, this.props.boundaryPolygonCoordinates)\n        ) {\n            this.props.addPoint(coordinate);\n        } else if (!this.state.isShiftPressed) {\n            this.props.deselectAllPoints();\n        }\n    };\n\n    handleMouseDownOnMap = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n\n        if (this.state.isShiftPressed) {\n            this.setState({\n                rectangleSelection: {\n                    startPosition: coordinate,\n                    endPosition: coordinate,\n                    startTime: new Date().getTime(),\n                },\n            });\n        }\n    };\n\n    handleMouseUpOnMap = () => {\n        if (this.state.rectangleSelection) {\n            this.setState({\n                rectangleSelection: null,\n            });\n        }\n    };\n\n    handleMouseMoveOnMap = (event: LeafletMouseEvent) => {\n        const mouseCoordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (this.state.rectangleSelection && new Date().getTime() - this.state.rectangleSelection?.startTime >= 100) {\n            const start = this.state.rectangleSelection.startPosition;\n            if (start) {\n                const bounds: LatLngBounds = latLngBounds(createLeafletLatLngFromCoordinate(start), event.latlng);\n\n                const activePolygon: Coordinate[] | undefined =\n                    this.props.polygonCoordinates[this.props.activePolygonIndex];\n                if (activePolygon) {\n                    const pointsInsideBounds: number[] = [];\n                    activePolygon.forEach((point, index) => {\n                        if (bounds.contains(createLeafletLatLngFromCoordinate(point))) {\n                            pointsInsideBounds.push(index);\n                        }\n                    });\n                    this.props.selectPoints(pointsInsideBounds);\n                }\n            }\n            this.setState({\n                rectangleSelection: {\n                    ...this.state.rectangleSelection,\n                    endPosition: mouseCoordinate,\n                },\n            });\n        } else {\n            const newPointPosition =\n                this.state.isPenToolActive &&\n                !this.props.isPolygonClosed &&\n                isCoordinateInPolygon(mouseCoordinate, this.props.boundaryPolygonCoordinates)\n                    ? mouseCoordinate\n                    : null;\n\n            this.setState({ newPointPosition });\n        }\n    };\n\n    handleMouseOutOfMap = () =>\n        this.setState({\n            newPointPosition: null,\n            rectangleSelection: null,\n        });\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Vertex methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    onPolygonVertexClick = (index: number) => {\n        if (\n            index === 0 &&\n            this.props.polygonCoordinates[this.props.activePolygonIndex].length > 2 &&\n            !this.props.isPolygonClosed\n        ) {\n            // Close polygon when user clicks the first point\n            this.props.addPoint({ ...this.props.polygonCoordinates[this.props.activePolygonIndex][0] });\n        } else if (this.state.isShiftPressed) {\n            if (this.props.selection.has(index)) {\n                this.props.removePointFromSelection(index);\n            } else {\n                this.props.addPointsToSelection([index]);\n            }\n        } else {\n            this.props.selectPoints([index]);\n        }\n    };\n\n    startVertexMove = (latLng: LatLng) => {\n        if (!this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: true,\n                previousMouseMovePosition: createCoordinateFromLeafletLatLng(latLng),\n            });\n        }\n    };\n\n    onPolygonVertexDragStart = (latLng: LatLng, index: number) => {\n        if (!this.props.selection.has(index)) {\n            if (this.state.isShiftPressed) {\n                this.props.addPointsToSelection([index]);\n            } else {\n                this.props.selectPoints([index]);\n            }\n        }\n        this.startVertexMove(latLng);\n    };\n\n    updateVertexPosition = (latLng: LatLng) => {\n        if (this.state.isMoveActive && this.state.previousMouseMovePosition) {\n            const coordinate: Coordinate = createCoordinateFromLeafletLatLng(latLng);\n            const moveVector = subtractCoordinates(coordinate, this.state.previousMouseMovePosition);\n\n            const nextCoordinates = Array.from(this.props.selection)\n                .map((i) => this.props.polygonCoordinates[this.props.activePolygonIndex][i])\n                .map((coord) => addCoordinates(coord, moveVector));\n\n            const inBoundary = nextCoordinates.every((nextCoordinate) =>\n                isCoordinateInPolygon(nextCoordinate, this.props.boundaryPolygonCoordinates)\n            );\n\n            if (inBoundary) {\n                this.props.moveSelectedPoints(moveVector);\n                this.setState({ previousMouseMovePosition: coordinate, isMovedPointInBoundary: true });\n            } else {\n                this.setState({ isMovedPointInBoundary: false });\n            }\n        }\n    };\n\n    endVertexMove = () => {\n        if (this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: false,\n                previousMouseMovePosition: undefined,\n                isMovedPointInBoundary: true,\n            });\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                      Keyboard handling methods                        //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleKeyDown = (e: KeyboardEvent) => {\n        e.preventDefault();\n        switch (e.key) {\n            case 'Escape':\n                this.props.deselectAllPoints();\n                break;\n            case 'Backspace':\n                this.props.deletePolygonPoints();\n                break;\n            case 'Shift':\n                this.setState({ isShiftPressed: true });\n                break;\n            case 'p':\n                this.toggleVectorMode();\n                break;\n            case 'd':\n                if (this.props.editable) {\n                    this.props.deselectAllPoints();\n                }\n                break;\n            case 'a':\n                if (this.props.editable) {\n                    this.props.selectAllPoints();\n                }\n                break;\n            case 'f':\n                this.reframe();\n                break;\n            case 'z':\n                if (e.metaKey && e.shiftKey) {\n                    this.props.onRedo();\n                } else if (e.metaKey) {\n                    this.props.onUndo();\n                }\n                break;\n        }\n    };\n\n    handleKeyUp = (e: KeyboardEvent) => {\n        switch (e.key) {\n            case 'Shift':\n                this.setState({ isShiftPressed: false });\n                break;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Render methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    renderPolygonVertex = (coordinate: Coordinate, index: number) => {\n        return (\n            <PolygonVertex\n                coordinate={coordinate}\n                isSelected={this.props.selection.has(index)}\n                key={index}\n                index={index}\n                onClick={this.onPolygonVertexClick}\n                onDragStart={this.onPolygonVertexDragStart}\n                onDrag={this.updateVertexPosition}\n                onDragEnd={this.endVertexMove}\n            />\n        );\n    };\n\n    renderActivePolygonPoints = () => {\n        return this.props.polygonCoordinates[this.props.activePolygonIndex].map(this.renderPolygonVertex);\n    };\n\n    renderVertexEdge = (coordinate: Coordinate, index: number) => (\n        <EdgeVertex key={index} index={index} coordinate={coordinate} onClick={this.props.addPointToEdge} />\n    );\n\n    renderPolygonEdges = () => {\n        return getPolygonEdges(this.props.polygonCoordinates[this.props.activePolygonIndex]).map(this.renderVertexEdge);\n    };\n\n    renderInactivePolygons = () => {\n        const activePolygonIsClosed = isPolygonClosed(this.props.polygonCoordinates[this.props.activePolygonIndex]);\n\n        return this.props.polygonCoordinates.map((coordinates, index) => {\n            const eventHandler = {\n                onClick: () => this.props.onClick && this.props.onClick(index),\n                onMouseEnter: () => this.props.onMouseEnter && this.props.onMouseEnter(index),\n                onMouseLeave: () => this.props.onMouseLeave && this.props.onMouseLeave(index),\n            };\n\n            return index === this.props.activePolygonIndex ? null : (\n                <Polygon\n                    key={`${index}-${coordinates.reduce((acc, cur) => acc + cur.latitude + cur.longitude, 0)}`}\n                    coordinates={coordinates}\n                    isActive={false}\n                    isHighlighted={index === this.props.highlightedPolygonIndex}\n                    {...(activePolygonIsClosed ? eventHandler : {})}\n                />\n            );\n        });\n    };\n\n    renderActivePolygon = () => {\n        const coordinates = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        const index = this.props.activePolygonIndex;\n        return (\n            <Polygon\n                coordinates={coordinates}\n                isActive\n                isHighlighted={false}\n                onClick={() => this.props.onClick && this.props.onClick(index)}\n                onMouseEnter={() => this.props.onMouseEnter && this.props.onMouseEnter(index)}\n                onMouseLeave={() => this.props.onMouseLeave && this.props.onMouseLeave(index)}\n            />\n        );\n    };\n\n    renderPolyline = () => {\n        const { newPointPosition } = this.state;\n        const polygon = this.props.polygonCoordinates[this.props.activePolygonIndex].map(\n            createLeafletLatLngFromCoordinate\n        );\n\n        if (polygon.length === 0) {\n            return null;\n        }\n\n        const newPath = [polygon[polygon.length - 1]];\n        if (newPointPosition) {\n            newPath.push(createLeafletLatLngFromCoordinate(newPointPosition));\n        }\n\n        return (\n            <>\n                <Polyline positions={polygon} color={MAP.POLYGON_ACTIVE_COLOR} interactive={false} />\n                <Polyline positions={newPath} color={MAP.POLYGON_ACTIVE_COLOR} dashArray=\"2 12\" interactive={false} />\n            </>\n        );\n    };\n\n    renderSelectionRectangle = () => {\n        if (this.state.rectangleSelection) {\n            const bounds: LatLngBounds = latLngBounds(\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.startPosition),\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.endPosition)\n            );\n\n            return (\n                <Rectangle\n                    color={MAP.RECTANGLE_SELECTION_COLOR}\n                    fillColor={MAP.RECTANGLE_SELECTION_COLOR}\n                    bounds={bounds}\n                />\n            );\n        }\n        return null;\n    };\n\n    render() {\n        const { editable,  drawable, selection, initialZoom, initialCenter } = this.props;\n        const { newPointPosition, isPenToolActive } = this.state;\n\n        return (\n            <Container>\n                <Map\n                    fadeAnimation\n                    trackResize\n                    zoomControl={false}\n                    ref={this.setMap}\n                    center={initialCenter}\n                    zoom={initialZoom}\n                    zoomDelta={2}\n                    zoomSnap={1.5}\n                    boxZoom={false}\n                    drawCursor={!!newPointPosition}\n                >\n                    <BoundaryPolygon\n                        coordinates={this.props.boundaryPolygonCoordinates}\n                        hasError={!this.state.isMovedPointInBoundary}\n                    />\n                    {this.props.isPolygonClosed ? this.renderActivePolygon() : this.renderPolyline()}\n                    {this.renderInactivePolygons()}\n\n                    {editable && (\n                        <Pane name=\"Polygon points\">\n                            {this.renderActivePolygonPoints()}\n                            {this.props.isPolygonClosed && isPenToolActive && this.renderPolygonEdges()}\n                        </Pane>\n                    )}\n\n                    {this.state.rectangleSelection && this.renderSelectionRectangle()}\n\n                    {/* <TileLayer /> */}\n                    <MapInner\n                        onClick={this.handleMapClick}\n                        onMouseOut={this.handleMouseOutOfMap}\n                        onMouseMove={this.handleMouseMoveOnMap}\n                        onMouseDown={this.handleMouseDownOnMap}\n                        onMouseUp={this.handleMouseUpOnMap}\n                    />\n                </Map>\n                <ActionBar\n                    editable={editable}\n                    drawable={drawable}\n                    isVectorModeEnabled={isPenToolActive}\n                    onDelete={this.props.deletePolygonPoints}\n                    onFocus={this.handleOnFocusClicked}\n                    onEnableVectorMode={this.toggleVectorMode}\n                    deleteInactive={selection.size === 0}\n                    onExport={this.handleExportPolygonActionClicked}\n                    onImport={this.handleImportPolygonActionClicked}\n                />\n\n                {this.state.showExportPolygonModal && (\n                    <Modal onClose={this.handleExportPolygonModalClosed}>\n                        <ExportPolygonForm\n                            polygon={this.props.polygonCoordinates[this.props.activePolygonIndex]}\n                            onSubmit={this.handleExportPolygon}\n                        />\n                    </Modal>\n                )}\n\n                {this.state.showImportPolygonModal && (\n                    <Modal onClose={this.handleImportPolygonModalClosed}>\n                        <ImportPolygonForm onSubmit={this.handleImportPolygon} />\n                    </Modal>\n                )}\n            </Container>\n        );\n    }\n}\n\nexport default memo(BaseMap);\n"],"names":[],"sourceRoot":""}