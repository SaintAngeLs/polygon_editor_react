{"version":3,"file":"PolygonDraw-stories.e8c3395a97fc744d116e.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAGA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAlEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AAGA;AACA;AAAA;AAOA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAGA;AACA;AAAA;AAYA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AA9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AAIA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAyDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAMA;AAAA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAEA;AACA;AAAA;AACA;AAKA;AAAA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AA5iBA;AA8iBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnoBA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAnBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AAGA;AAEA;AACA;AACA;AAAA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AA7DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAoBA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAnFA","sources":["webpack://@freenow/react-polygon-editor/./src/ActionBar/ActionBar.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/BoundaryPolygon.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/EdgeVertex.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/Map.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/Polygon.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/PolygonDraw.tsx","webpack://@freenow/react-polygon-editor/./src/PolygonDraw/PolygonVertex.tsx"],"sourcesContent":["import React, { FunctionComponent } from 'react';\nimport styled from 'styled-components';\n\nimport { FREEDOM_RED_900 } from '../common/colors';\n\nimport { ActionButton, ActionButtonIcons } from './ActionButton';\nimport { LABELS } from '../constants';\n\nconst Container = styled.div`\n    position: absolute;\n    right: 0;\n    bottom: 24px;\n    display: flex;\n\n    padding-right: 8px;\n    padding-left: 8px;\n\n    > * {\n        margin-left: 8px;\n    }\n`;\n\nexport interface Props {\n    editable: boolean;\n\n    drawable: boolean;\n\n    onFocus: () => void;\n\n    onEnableVectorMode: () => void;\n    isVectorModeEnabled: boolean;\n\n    onEnableDrawMode: () => void;\n    isDrawModeEnabled: boolean;\n\n    onDelete: () => void;\n    deleteInactive: boolean;\n\n    onExport: () => void;\n    onImport: () => void;\n}\n\nexport const ActionBar: FunctionComponent<Props> = ({\n    editable,\n    drawable,\n    deleteInactive,\n    isVectorModeEnabled,\n    onEnableVectorMode,\n    onEnableDrawMode,\n    isDrawModeEnabled,\n    onFocus,\n    onDelete,\n    onExport,\n    onImport,\n}) => (\n    <Container>\n        {editable && (\n            <>\n                <ActionButton\n                    onClick={onEnableVectorMode}\n                    icon={ActionButtonIcons.VECTOR_MODE}\n                    inactive={!isVectorModeEnabled}\n                    aria-label={`${isVectorModeEnabled ? 'Disable Editing' : 'Enable Editing'}`}\n                >\n                    {LABELS.PEN}\n                </ActionButton>\n                <ActionButton\n                    onClick={onDelete}\n                    icon={ActionButtonIcons.TRASHCAN}\n                    activeIconColor={FREEDOM_RED_900}\n                    disabled={deleteInactive}\n                    inactive={deleteInactive}\n                    aria-label=\"Delete\"\n                >\n                    {LABELS.DELETE}\n                </ActionButton>\n            </>\n        )}\n        {drawable && (\n            <>\n                <ActionButton\n                    onClick={onEnableDrawMode}\n                    icon={ActionButtonIcons.DRAW_MODE}\n                    inactive={!isDrawModeEnabled}\n                    aria-label={`${isDrawModeEnabled ? 'Disable Drawing' : 'Enable Drawing'}`}\n                >\n                    {LABELS.PEN}\n                </ActionButton>\n                <ActionButton\n                    onClick={onDelete}\n                    icon={ActionButtonIcons.TRASHCAN}\n                    activeIconColor={FREEDOM_RED_900}\n                    disabled={deleteInactive}\n                    inactive={deleteInactive}\n                    aria-label=\"Delete\"\n                >\n                    {LABELS.DELETE}\n                </ActionButton>\n            </>\n        )}\n        <ActionButton onClick={onImport} icon={ActionButtonIcons.IMPORT}>\n            {LABELS.IMPORT}\n        </ActionButton>\n        <ActionButton onClick={onExport} icon={ActionButtonIcons.EXPORT}>\n            {LABELS.EXPORT}\n        </ActionButton>\n        <ActionButton onClick={onFocus} icon={ActionButtonIcons.FRAME}>\n            {LABELS.FOCUS}\n        </ActionButton>\n    </Container>\n);\n","import React, { FunctionComponent } from 'react';\nimport { Polygon as LeafletPolygon } from 'react-leaflet';\n\nimport { Coordinate } from 'types';\nimport { createLeafletLatLngFromCoordinate } from '../helpers';\nimport { MAP } from '../constants';\n\ninterface Props {\n    coordinates: Coordinate[];\n    hasError: boolean;\n}\n\nexport const BoundaryPolygon: FunctionComponent<Props> = ({ coordinates, hasError }) => (\n    <LeafletPolygon\n        positions={[MAP.WORLD_LAT_LNG_COORDINATES, coordinates.map(createLeafletLatLngFromCoordinate)]}\n        fillColor={MAP.BOUNDARY_COLOR}\n        color={hasError ? MAP.ERROR_BOUNDARY_COLOR : MAP.BOUNDARY_COLOR}\n        weight={hasError ? MAP.BORDER_WIDTH : 0.4}\n        interactive={false}\n    />\n);\n","import React from 'react';\nimport { CircleMarker as LeafletCircleMarker } from 'react-leaflet';\n\nimport { Coordinate } from 'types';\nimport { createLeafletLatLngFromCoordinate } from '../helpers';\nimport { MAP } from '../constants';\n\ninterface Props {\n    coordinate: Coordinate;\n    index: number;\n    onClick: (coordinate: Coordinate, index: number) => void;\n}\n\ninterface State {\n    isHoverActive: boolean;\n}\n\nexport class EdgeVertex extends React.Component<Props, State> {\n    state = {\n        isHoverActive: false,\n    };\n\n    handleMouseOver = () => this.setState({ isHoverActive: true });\n    handleMouseOut = () => this.setState({ isHoverActive: false });\n    handleClick = () => this.props.onClick(this.props.coordinate, this.props.index);\n\n    render() {\n        const { isHoverActive } = this.state;\n        const { coordinate } = this.props;\n\n        return (\n            <LeafletCircleMarker\n                fillColor={MAP.VERTEX_FILL_COLOR}\n                fillOpacity={isHoverActive ? 1 : 0.8}\n                color={MAP.POLYGON_ACTIVE_COLOR}\n                opacity={isHoverActive ? 1 : 0.8}\n                weight={isHoverActive ? 2 : 0.5}\n                radius={isHoverActive ? 6 : 3}\n                center={createLeafletLatLngFromCoordinate(coordinate)}\n                eventHandlers={{\n                    click: this.handleClick,\n                    mouseover: this.handleMouseOver,\n                    mouseout: this.handleMouseOut,\n                }}\n            />\n        );\n    }\n}\n","import React, { memo } from 'react';\nimport { LatLng, latLngBounds, LatLngBounds, LatLngTuple, LeafletMouseEvent } from 'leaflet';\nimport { useMap, Pane, Polyline, Rectangle } from 'react-leaflet';\nimport flatten from 'lodash.flatten';\n\nimport { Coordinate } from 'types';\n\nimport {\n    createCoordinateFromLeafletLatLng,\n    createLeafletLatLngBoundsFromCoordinates,\n    createLeafletLatLngFromCoordinate,\n    addCoordinates,\n    subtractCoordinates,\n    getPolygonEdges,\n    isCoordinateInPolygon,\n    isPolygonClosed,\n} from '../helpers';\nimport { Modal } from '../common/components/Modal';\nimport { ExportPolygonForm } from '../conversion/ExportPolygonForm';\nimport { ImportPolygonForm } from '../conversion/ImportPolygonForm';\n//import { TileLayer } from '../leaflet/TileLayer';\nimport { MAP } from '../constants';\nimport { Map, Container } from '../leaflet/Map';\nimport { ActionBar } from '../ActionBar/ActionBar';\nimport { EdgeVertex } from './EdgeVertex';\nimport { PolygonVertex } from './PolygonVertex';\nimport { BoundaryPolygon } from './BoundaryPolygon';\nimport { Polygon } from './Polygon';\nimport MapInner from './MapInner';\n\ninterface MapSnapshot {\n    reframe: boolean;\n    size: string;\n}\n\nexport interface Props {\n    /**\n     * activePolygonIndex is the index of the polygon that is currently available for editing\n     */\n    activePolygonIndex: number;\n    highlightedPolygonIndex?: number;\n    polygonCoordinates: Coordinate[][];\n    boundaryPolygonCoordinates: Coordinate[];\n    selection: Set<number>;\n    editable: boolean;\n    drawable: boolean;\n    initialCenter: LatLngTuple;\n    initialZoom: number;\n    isPolygonClosed: boolean;\n    onClick?: (index: number) => void;\n    onMouseEnter?: (index: number) => void;\n    onMouseLeave?: (index: number) => void;\n    addPoint: (coord: Coordinate) => void;\n    addPointToEdge: (coordinate: Coordinate, index: number) => void;\n    deselectAllPoints: () => void;\n    removePointFromSelection: (index: number) => void;\n    addPointsToSelection: (indices: number[]) => void;\n    selectPoints: (indices: number[]) => void;\n    moveSelectedPoints: (newPosition: Coordinate) => void;\n    deletePolygonPoints: () => void;\n    selectAllPoints: () => void;\n    setPolygon: (polygon: Coordinate[]) => void;\n    onUndo: () => void;\n    onRedo: () => void;\n}\n\ntype MapType = ReturnType<typeof useMap>;\n\nexport interface State {\n    isMovedPointInBoundary: boolean;\n    isShiftPressed: boolean;\n    isMoveActive: boolean;\n    rectangleSelection: {\n        startPosition: Coordinate;\n        endPosition: Coordinate;\n        startTime: number;\n    } | null;\n    previousMouseMovePosition?: Coordinate;\n    isPenToolActive: boolean;\n    isDrawToolActive: boolean;\n    newPointPosition: Coordinate | null;\n    showExportPolygonModal: boolean;\n    showImportPolygonModal: boolean;\n}\n\nexport class BaseMap extends React.Component<Props, State> {\n    private map: MapType | null = null;\n\n    state: State = {\n        isMovedPointInBoundary: true,\n        isShiftPressed: false,\n        isMoveActive: false,\n        rectangleSelection: null,\n        previousMouseMovePosition: undefined,\n        isPenToolActive: false,\n        isDrawToolActive: false,\n        newPointPosition: null,\n        showExportPolygonModal: false,\n        showImportPolygonModal: false,\n    };\n\n    static getDerivedStateFromProps(props: Props, state: State): State {\n        return {\n            ...state,\n            isPenToolActive: props.polygonCoordinates.length === 0 ? true : state.isPenToolActive,\n        };\n    }\n\n    componentDidMount() {\n        this.reframe();\n        this.toggleVectorMode();\n\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.addEventListener('keydown', this.handleKeyDown, false);\n            container.addEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    componentWillUnmount() {\n        const container = this.map?.getContainer();\n\n        if (container) {\n            container.removeEventListener('keydown', this.handleKeyDown, false);\n            container.removeEventListener('keyup', this.handleKeyUp);\n        }\n    }\n\n    getSnapshotBeforeUpdate(prevProps: Props, prevState: State): MapSnapshot {\n        const reframe =\n            // Reframe when the polygon loads for the first time\n            (prevProps.polygonCoordinates[prevProps.activePolygonIndex].length === 0 &&\n                this.props.polygonCoordinates[this.props.activePolygonIndex].length > 1) ||\n            // Reframe when the boundary polygon loads for the first time\n            prevProps.boundaryPolygonCoordinates !== this.props.boundaryPolygonCoordinates;\n\n        const size = this.getSize(this.map);\n\n        return { reframe, size };\n    }\n\n    componentDidUpdate(prevProps: Readonly<Props>, prevState: Readonly<State>, { reframe, size }: MapSnapshot): void {\n        if (reframe) {\n            this.reframe();\n        }\n\n        if (this.map && this.getSize(this.map) !== size) {\n            this.map.invalidateSize();\n        }\n    }\n\n    setMap = (map: MapType) => {\n        if (map) {\n            this.map = map;\n\n            this.reframe();\n            this.toggleVectorMode();\n\n            const container = map?.getContainer();\n\n            if (container) {\n                container?.addEventListener('keydown', this.handleKeyDown, false);\n                container?.addEventListener('keyup', this.handleKeyUp);\n            }\n        }\n    };\n\n    reframe = () => {\n        const { polygonCoordinates, boundaryPolygonCoordinates, initialCenter, initialZoom } = this.props;\n\n        if (polygonCoordinates[this.props.activePolygonIndex].length > 1) {\n            this.reframeOnPolygon(polygonCoordinates);\n        } else if (boundaryPolygonCoordinates.length > 0 && boundaryPolygonCoordinates !== MAP.WORLD_COORDINATES) {\n            this.reframeOnPolygon(boundaryPolygonCoordinates);\n        } else if (this.map) {\n            this.map.setView(initialCenter, initialZoom);\n        }\n    };\n\n    reframeOnPolygon = (polygonCoordinates: Coordinate[] | Coordinate[][]) => {\n        if (this.map && polygonCoordinates.length > 0) {\n            const bounds = createLeafletLatLngBoundsFromCoordinates(flatten(polygonCoordinates));\n\n            this.map.fitBounds(bounds);\n        }\n    };\n\n    toggleVectorMode = () => {\n        if (!this.props.editable) {\n            return;\n        }\n        this.setState({\n            isPenToolActive: !this.state.isPenToolActive,\n            newPointPosition: null,\n        });\n    };\n\n    toggleDrawMode = () => {\n        if (!this.props.drawable) {\n            return;\n        }\n        this.setState({\n            isPenToolActive: !this.state.isPenToolActive,\n            newPointPosition: null,\n        });\n    };\n\n    getSize = (map: MapType | null): string => {\n        const container = map?.getContainer();\n        return container ? `${container.clientHeight}x${container.clientWidth}` : '';\n    };\n\n    handleOnFocusClicked = () => {\n        const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        if (activePolygon) {\n            this.reframeOnPolygon(activePolygon);\n        } else {\n            this.reframe();\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Export / Import methods                      //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleExportPolygon = (serialized: string) => {\n        navigator.clipboard.writeText(serialized);\n    };\n\n    handleExportPolygonActionClicked = () => {\n        this.setState({ showExportPolygonModal: true });\n    };\n\n    handleExportPolygonModalClosed = () => {\n        this.setState({ showExportPolygonModal: false });\n    };\n\n    handleImportPolygon = (coordinates: Coordinate[]) => {\n        this.props.setPolygon(coordinates);\n        this.reframeOnPolygon(coordinates);\n    };\n\n    handleImportPolygonActionClicked = () => {\n        this.setState({ showImportPolygonModal: true });\n    };\n\n    handleImportPolygonModalClosed = () => {\n        this.setState({ showImportPolygonModal: false });\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                          Map Events methods                           //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleMapClick = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (\n            this.state.isPenToolActive &&\n            !this.props.isPolygonClosed &&\n            isCoordinateInPolygon(coordinate, this.props.boundaryPolygonCoordinates)\n        ) {\n            this.props.addPoint(coordinate);\n        } else if (!this.state.isShiftPressed) {\n            this.props.deselectAllPoints();\n        }\n    };\n\n    handleMouseDownOnMap = (event: LeafletMouseEvent) => {\n        const coordinate = createCoordinateFromLeafletLatLng(event.latlng);\n\n        if (this.state.isShiftPressed) {\n            this.setState({\n                rectangleSelection: {\n                    startPosition: coordinate,\n                    endPosition: coordinate,\n                    startTime: new Date().getTime(),\n                },\n            });\n        }\n    };\n\n    handleMouseUpOnMap = () => {\n        if (this.state.rectangleSelection) {\n            this.setState({\n                rectangleSelection: null,\n            });\n        }\n    };\n\n    handleMouseMoveOnMap = (event: LeafletMouseEvent) => {\n        const mouseCoordinate = createCoordinateFromLeafletLatLng(event.latlng);\n        if (this.state.rectangleSelection && new Date().getTime() - this.state.rectangleSelection?.startTime >= 100) {\n            const start = this.state.rectangleSelection.startPosition;\n            if (start) {\n                const bounds: LatLngBounds = latLngBounds(createLeafletLatLngFromCoordinate(start), event.latlng);\n\n                const activePolygon: Coordinate[] | undefined =\n                    this.props.polygonCoordinates[this.props.activePolygonIndex];\n                if (activePolygon) {\n                    const pointsInsideBounds: number[] = [];\n                    activePolygon.forEach((point, index) => {\n                        if (bounds.contains(createLeafletLatLngFromCoordinate(point))) {\n                            pointsInsideBounds.push(index);\n                        }\n                    });\n                    this.props.selectPoints(pointsInsideBounds);\n                }\n            }\n            this.setState({\n                rectangleSelection: {\n                    ...this.state.rectangleSelection,\n                    endPosition: mouseCoordinate,\n                },\n            });\n        } else {\n            const newPointPosition =\n                this.state.isPenToolActive &&\n                !this.props.isPolygonClosed &&\n                isCoordinateInPolygon(mouseCoordinate, this.props.boundaryPolygonCoordinates)\n                    ? mouseCoordinate\n                    : null;\n\n            this.setState({ newPointPosition });\n        }\n    };\n\n    handleMouseOutOfMap = () =>\n        this.setState({\n            newPointPosition: null,\n            rectangleSelection: null,\n        });\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Vertex methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    onPolygonVertexClick = (index: number) => {\n        if (\n            index === 0 &&\n            this.props.polygonCoordinates[this.props.activePolygonIndex].length > 2 &&\n            !this.props.isPolygonClosed\n        ) {\n            // Close polygon when user clicks the first point\n            this.props.addPoint({ ...this.props.polygonCoordinates[this.props.activePolygonIndex][0] });\n        } else if (this.state.isShiftPressed) {\n            if (this.props.selection.has(index)) {\n                this.props.removePointFromSelection(index);\n            } else {\n                this.props.addPointsToSelection([index]);\n            }\n        } else {\n            this.props.selectPoints([index]);\n        }\n    };\n\n    startVertexMove = (latLng: LatLng) => {\n        if (!this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: true,\n                previousMouseMovePosition: createCoordinateFromLeafletLatLng(latLng),\n            });\n        }\n    };\n\n    onPolygonVertexDragStart = (latLng: LatLng, index: number) => {\n        if (!this.props.selection.has(index)) {\n            if (this.state.isShiftPressed) {\n                this.props.addPointsToSelection([index]);\n            } else {\n                this.props.selectPoints([index]);\n            }\n        }\n        this.startVertexMove(latLng);\n    };\n\n    updateVertexPosition = (latLng: LatLng) => {\n        if (this.state.isMoveActive && this.state.previousMouseMovePosition) {\n            const coordinate: Coordinate = createCoordinateFromLeafletLatLng(latLng);\n            const moveVector = subtractCoordinates(coordinate, this.state.previousMouseMovePosition);\n\n            const nextCoordinates = Array.from(this.props.selection)\n                .map((i) => this.props.polygonCoordinates[this.props.activePolygonIndex][i])\n                .map((coord) => addCoordinates(coord, moveVector));\n\n            const inBoundary = nextCoordinates.every((nextCoordinate) =>\n                isCoordinateInPolygon(nextCoordinate, this.props.boundaryPolygonCoordinates)\n            );\n\n            if (inBoundary) {\n                this.props.moveSelectedPoints(moveVector);\n                this.setState({ previousMouseMovePosition: coordinate, isMovedPointInBoundary: true });\n            } else {\n                this.setState({ isMovedPointInBoundary: false });\n            }\n        }\n    };\n\n    endVertexMove = () => {\n        if (this.state.isMoveActive) {\n            this.setState({\n                isMoveActive: false,\n                previousMouseMovePosition: undefined,\n                isMovedPointInBoundary: true,\n            });\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                      Keyboard handling methods                        //\n    ///////////////////////////////////////////////////////////////////////////\n\n    handleKeyDown = (e: KeyboardEvent) => {\n        e.preventDefault();\n        switch (e.key) {\n            case 'Escape':\n                this.props.deselectAllPoints();\n                break;\n            case 'Backspace':\n                this.props.deletePolygonPoints();\n                break;\n            case 'Shift':\n                this.setState({ isShiftPressed: true });\n                break;\n            case 'p':\n                this.toggleVectorMode();\n                break;\n            case 'd':\n                if (this.props.editable) {\n                    this.props.deselectAllPoints();\n                }\n                break;\n            case 'a':\n                if (this.props.editable) {\n                    this.props.selectAllPoints();\n                }\n                break;\n            case 'f':\n                this.reframe();\n                break;\n            case 'z':\n                if (e.metaKey && e.shiftKey) {\n                    this.props.onRedo();\n                } else if (e.metaKey) {\n                    this.props.onUndo();\n                }\n                break;\n        }\n    };\n\n    handleKeyUp = (e: KeyboardEvent) => {\n        switch (e.key) {\n            case 'Shift':\n                this.setState({ isShiftPressed: false });\n                break;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                           Render methods                              //\n    ///////////////////////////////////////////////////////////////////////////\n\n    renderPolygonVertex = (coordinate: Coordinate, index: number) => {\n        return (\n            <PolygonVertex\n                coordinate={coordinate}\n                isSelected={this.props.selection.has(index)}\n                key={index}\n                index={index}\n                onClick={this.onPolygonVertexClick}\n                onDragStart={this.onPolygonVertexDragStart}\n                onDrag={this.updateVertexPosition}\n                onDragEnd={this.endVertexMove}\n            />\n        );\n    };\n\n    renderActivePolygonPoints = () => {\n        return this.props.polygonCoordinates[this.props.activePolygonIndex].map(this.renderPolygonVertex);\n    };\n\n    renderVertexEdge = (coordinate: Coordinate, index: number) => (\n        <EdgeVertex key={index} index={index} coordinate={coordinate} onClick={this.props.addPointToEdge} />\n    );\n\n    renderPolygonEdges = () => {\n        return getPolygonEdges(this.props.polygonCoordinates[this.props.activePolygonIndex]).map(this.renderVertexEdge);\n    };\n\n    renderInactivePolygons = () => {\n        const activePolygonIsClosed = isPolygonClosed(this.props.polygonCoordinates[this.props.activePolygonIndex]);\n\n        return this.props.polygonCoordinates.map((coordinates, index) => {\n            const eventHandler = {\n                onClick: () => this.props.onClick && this.props.onClick(index),\n                onMouseEnter: () => this.props.onMouseEnter && this.props.onMouseEnter(index),\n                onMouseLeave: () => this.props.onMouseLeave && this.props.onMouseLeave(index),\n            };\n\n            return index === this.props.activePolygonIndex ? null : (\n                <Polygon\n                    key={`${index}-${coordinates.reduce((acc, cur) => acc + cur.latitude + cur.longitude, 0)}`}\n                    coordinates={coordinates}\n                    isActive={false}\n                    isHighlighted={index === this.props.highlightedPolygonIndex}\n                    {...(activePolygonIsClosed ? eventHandler : {})}\n                />\n            );\n        });\n    };\n\n    renderActivePolygon = () => {\n        const coordinates = this.props.polygonCoordinates[this.props.activePolygonIndex];\n        const index = this.props.activePolygonIndex;\n        return (\n            <Polygon\n                coordinates={coordinates}\n                isActive\n                isHighlighted={false}\n                onClick={() => this.props.onClick && this.props.onClick(index)}\n                onMouseEnter={() => this.props.onMouseEnter && this.props.onMouseEnter(index)}\n                onMouseLeave={() => this.props.onMouseLeave && this.props.onMouseLeave(index)}\n            />\n        );\n    };\n\n    renderPolyline = () => {\n        const { newPointPosition } = this.state;\n        const polygon = this.props.polygonCoordinates[this.props.activePolygonIndex].map(\n            createLeafletLatLngFromCoordinate\n        );\n\n        if (polygon.length === 0) {\n            return null;\n        }\n\n        const newPath = [polygon[polygon.length - 1]];\n        if (newPointPosition) {\n            newPath.push(createLeafletLatLngFromCoordinate(newPointPosition));\n        }\n\n        return (\n            <>\n                <Polyline positions={polygon} color={MAP.POLYGON_ACTIVE_COLOR} interactive={false} />\n                <Polyline positions={newPath} color={MAP.POLYGON_ACTIVE_COLOR} dashArray=\"2 12\" interactive={false} />\n            </>\n        );\n    };\n\n    renderSelectionRectangle = () => {\n        if (this.state.rectangleSelection) {\n            const bounds: LatLngBounds = latLngBounds(\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.startPosition),\n                createLeafletLatLngFromCoordinate(this.state.rectangleSelection.endPosition)\n            );\n\n            return (\n                <Rectangle\n                    color={MAP.RECTANGLE_SELECTION_COLOR}\n                    fillColor={MAP.RECTANGLE_SELECTION_COLOR}\n                    bounds={bounds}\n                />\n            );\n        }\n        return null;\n    };\n\n    render() {\n        const { editable,  drawable, selection, initialZoom, initialCenter } = this.props;\n        const { newPointPosition, isPenToolActive, isDrawToolActive } = this.state;\n\n        return (\n            <Container>\n                <Map\n                    fadeAnimation\n                    trackResize\n                    zoomControl={false}\n                    ref={this.setMap}\n                    center={initialCenter}\n                    zoom={initialZoom}\n                    zoomDelta={2}\n                    zoomSnap={1.5}\n                    boxZoom={false}\n                    drawCursor={!!newPointPosition}\n                >\n                    <BoundaryPolygon\n                        coordinates={this.props.boundaryPolygonCoordinates}\n                        hasError={!this.state.isMovedPointInBoundary}\n                    />\n                    {this.props.isPolygonClosed ? this.renderActivePolygon() : this.renderPolyline()}\n                    {this.renderInactivePolygons()}\n\n                    {editable && (\n                        <Pane name=\"Polygon points\">\n                            {this.renderActivePolygonPoints()}\n                            {this.props.isPolygonClosed && isPenToolActive && this.renderPolygonEdges()}\n                        </Pane>\n                    )}\n\n                    {this.state.rectangleSelection && this.renderSelectionRectangle()}\n\n                    {/* <TileLayer /> */}\n                    <MapInner\n                        onClick={this.handleMapClick}\n                        onMouseOut={this.handleMouseOutOfMap}\n                        onMouseMove={this.handleMouseMoveOnMap}\n                        onMouseDown={this.handleMouseDownOnMap}\n                        onMouseUp={this.handleMouseUpOnMap}\n                    />\n                </Map>\n                <ActionBar\n                    editable={editable}\n                    drawable={drawable}\n                    isVectorModeEnabled={isPenToolActive}\n                    isDrawModeEnabled={isDrawToolActive}\n                    onDelete={this.props.deletePolygonPoints}\n                    onFocus={this.handleOnFocusClicked}\n                    onEnableDrawMode={this.toggleDrawMode}\n                    onEnableVectorMode={this.toggleVectorMode}\n                    deleteInactive={selection.size === 0}\n                    onExport={this.handleExportPolygonActionClicked}\n                    onImport={this.handleImportPolygonActionClicked}\n                />\n\n                {this.state.showExportPolygonModal && (\n                    <Modal onClose={this.handleExportPolygonModalClosed}>\n                        <ExportPolygonForm\n                            polygon={this.props.polygonCoordinates[this.props.activePolygonIndex]}\n                            onSubmit={this.handleExportPolygon}\n                        />\n                    </Modal>\n                )}\n\n                {this.state.showImportPolygonModal && (\n                    <Modal onClose={this.handleImportPolygonModalClosed}>\n                        <ImportPolygonForm onSubmit={this.handleImportPolygon} />\n                    </Modal>\n                )}\n            </Container>\n        );\n    }\n}\n\nexport default memo(BaseMap);\n","import React, { FunctionComponent } from 'react';\nimport { Polygon as LeafletPolygon } from 'react-leaflet';\n\nimport { Coordinate } from 'types';\nimport { createLeafletLatLngFromCoordinate } from '../helpers';\nimport { MAP } from '../constants';\n\n// refers to https://leafletjs.com/reference-1.6.0.html#path-dasharray and\n// https://developer.mozilla.org/de/docs/Web/SVG/Attribute/stroke-dasharray\n// 4 describes the dash size, 12 the gap size\nconst DASH_STROKE_SIZE = '1 4';\n\ninterface Props {\n    coordinates: Coordinate[];\n    isActive: boolean;\n    isHighlighted: boolean;\n    onClick?: () => void;\n    onMouseEnter?: () => void;\n    onMouseLeave?: () => void;\n}\n\nexport const Polygon: FunctionComponent<Props> = ({\n    isActive,\n    isHighlighted,\n    coordinates,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n}) => (\n    <LeafletPolygon\n        positions={coordinates.map(createLeafletLatLngFromCoordinate)}\n        dashArray={isActive ? '' : DASH_STROKE_SIZE}\n        fillColor={isActive || isHighlighted ? MAP.POLYGON_ACTIVE_COLOR : MAP.POLYGON_INACTIVE_COLOR}\n        weight={MAP.BORDER_WIDTH}\n        color={isActive ? MAP.POLYGON_ACTIVE_COLOR : MAP.POLYGON_INACTIVE_COLOR}\n        data-testid=\"polygon\"\n        eventHandlers={{\n            click: onClick,\n            mouseover: onMouseEnter,\n            mouseout: onMouseLeave,\n        }}\n    />\n);\n","import React from 'react';\n\nimport { Coordinate } from 'types';\nimport { createLeafletLatLngTupleFromCoordinate } from '../helpers';\n\nimport { MAP } from '../constants';\nimport Map from './Map';\nimport { usePolygonEditor } from './usePolygonEditor';\n\nexport type Props<T extends Coordinate[] | Coordinate[][]> = {\n    boundary?: Coordinate[];\n    initialCenter?: Coordinate;\n    initialZoom?: number;\n    editable?: boolean;\n    drawable?: boolean;\n    onChange?: (polygon: T, isValid: boolean) => void;\n    polygon: T;\n    activeIndex?: number;\n    highlightedIndex?: number;\n    onClick?: (index: number) => void;\n    onMouseEnter?: (index: number) => void;\n    onMouseLeave?: (index: number) => void;\n};\n\nexport function PolygonDraw<T extends Coordinate[] | Coordinate[][]>({\n    polygon,\n    activeIndex = 0,\n    highlightedIndex,\n    boundary,\n    initialCenter,\n    initialZoom,\n    editable = true,\n    drawable = true,\n    onChange,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n}: Props<T>): React.ReactElement {\n    const {\n        polygons,\n        selection,\n        addPoint,\n        addPointToEdge,\n        setPolygon,\n        deselectAllPoints,\n        removePointFromSelection,\n        addPointsToSelection,\n        selectPoints,\n        moveSelectedPoints,\n        deletePolygonPoints,\n        selectAllPoints,\n        isPolygonClosed,\n        undo,\n        redo,\n    } = usePolygonEditor(onChange, polygon, activeIndex);\n\n    return (\n        <Map\n            selection={selection}\n            editable={editable}\n            drawable={drawable}\n            initialCenter={initialCenter ? createLeafletLatLngTupleFromCoordinate(initialCenter) : MAP.DEFAULT_CENTER}\n            initialZoom={initialZoom || MAP.DEFAULT_ZOOM}\n            boundaryPolygonCoordinates={boundary || MAP.WORLD_COORDINATES}\n            activePolygonIndex={activeIndex}\n            highlightedPolygonIndex={highlightedIndex}\n            polygonCoordinates={polygons}\n            setPolygon={setPolygon}\n            addPoint={addPoint}\n            addPointToEdge={addPointToEdge}\n            deselectAllPoints={deselectAllPoints}\n            removePointFromSelection={removePointFromSelection}\n            addPointsToSelection={addPointsToSelection}\n            selectPoints={selectPoints}\n            moveSelectedPoints={moveSelectedPoints}\n            deletePolygonPoints={deletePolygonPoints}\n            selectAllPoints={selectAllPoints}\n            isPolygonClosed={isPolygonClosed}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            onUndo={undo}\n            onRedo={redo}\n        />\n    );\n}\n","import 'leaflet-path-drag';\nimport React from 'react';\nimport { CircleMarker, LatLng } from 'leaflet';\nimport { CircleMarker as ReactLeafletCircleMarker } from 'react-leaflet';\n\nimport { Coordinate } from 'types';\nimport { createLeafletLatLngFromCoordinate } from '../helpers';\nimport { MAP } from '../constants';\n\ntype DragEvent = { target: { getLatLng: () => LatLng } };\n\nexport interface Props {\n    coordinate: Coordinate;\n    isSelected: boolean;\n    index: number;\n    onClick: (index: number) => void;\n    onDragStart: (latlng: LatLng, index: number) => void;\n    onDrag: (latlng: LatLng) => void;\n    onDragEnd: () => void;\n}\n\nexport interface State {\n    isHovered: boolean;\n    isDragged: boolean;\n    latLng: LatLng;\n}\n\nexport class PolygonVertex extends React.Component<Props, State> {\n    private circleMarkerElement: CircleMarker;\n    state = {\n        isHovered: false,\n        isDragged: false,\n        latLng: new LatLng(0, 0),\n    };\n\n    static getDerivedStateFromProps = (props: Props, state: State) => {\n        return state.isDragged ? state : { ...state, latLng: createLeafletLatLngFromCoordinate(props.coordinate) };\n    };\n\n    componentDidMount() {\n        if (this.circleMarkerElement) {\n            this.circleMarkerElement.on('dragstart', this.handleDragStart);\n            this.circleMarkerElement.on('drag', this.handleDrag);\n            this.circleMarkerElement.on('dragend', this.handleDragEnd);\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.circleMarkerElement) {\n            this.circleMarkerElement.off('dragstart', this.handleDragStart);\n            this.circleMarkerElement.off('drag', this.handleDrag);\n            this.circleMarkerElement.off('dragend', this.handleDragEnd);\n        }\n    }\n\n    // tslint:disable-next-line\n    setCircleMarkerRef = (ref: any) => {\n        if (ref) {\n            this.circleMarkerElement = ref;\n        }\n    };\n\n    handleClick = () => this.props.onClick(this.props.index);\n    handleMouseOver = () => this.setState({ isHovered: true });\n    handleMouseOut = () => this.setState({ isHovered: false });\n\n    handleDragStart = (event: DragEvent) => {\n        this.props.onDragStart(event.target.getLatLng(), this.props.index);\n        this.setState({ isDragged: true });\n    };\n\n    handleDrag = (event: DragEvent) => {\n        if (this.state.isDragged) {\n            this.props.onDrag(event.target.getLatLng());\n        }\n    };\n\n    handleDragEnd = () => {\n        this.props.onDragEnd();\n        this.setState({ isDragged: false });\n    };\n\n    render() {\n        const { isSelected } = this.props;\n        const { isHovered, latLng } = this.state;\n        const selectedOrHovered = isSelected || isHovered;\n        const hoveredAndNotSelected = isHovered && !isSelected;\n\n        return (\n            <ReactLeafletCircleMarker\n                aria-label=\"Polygon\"\n                ref={this.setCircleMarkerRef}\n                fillColor={MAP.VERTEX_FILL_COLOR}\n                fillOpacity={1}\n                color={MAP.POLYGON_ACTIVE_COLOR}\n                opacity={hoveredAndNotSelected ? 0.6 : 1}\n                weight={selectedOrHovered ? 4 : 1}\n                radius={selectedOrHovered ? 6 : 4}\n                center={latLng}\n                eventHandlers={{\n                    click: this.handleClick,\n                    mouseover: this.handleMouseOver,\n                    mouseout: this.handleMouseOut,\n                }}\n                bubblingMouseEvents={false}\n                // @ts-ignore\n                draggable\n            />\n        );\n    }\n}\n"],"names":[],"sourceRoot":""}