"use strict";
self["webpackHotUpdate_freenow_react_polygon_editor"]("PolygonDraw-stories",{

/***/ "./src/PolygonDraw/Map.tsx":
/*!*********************************!*\
  !*** ./src/PolygonDraw/Map.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseMap: () => (/* binding */ BaseMap),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! react-leaflet */ "./node_modules/react-leaflet/lib/Polyline.js");
/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! react-leaflet */ "./node_modules/react-leaflet/lib/Rectangle.js");
/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! react-leaflet */ "./node_modules/react-leaflet/lib/Pane.js");
/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.flatten */ "./node_modules/lodash.flatten/index.js");
/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_flatten__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.ts");
/* harmony import */ var _common_components_Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/components/Modal */ "./src/common/components/Modal.tsx");
/* harmony import */ var _conversion_ExportPolygonForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../conversion/ExportPolygonForm */ "./src/conversion/ExportPolygonForm.tsx");
/* harmony import */ var _conversion_ImportPolygonForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../conversion/ImportPolygonForm */ "./src/conversion/ImportPolygonForm.tsx");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/* harmony import */ var _leaflet_Map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../leaflet/Map */ "./src/leaflet/Map.tsx");
/* harmony import */ var _ActionBar_ActionBar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ActionBar/ActionBar */ "./src/ActionBar/ActionBar.tsx");
/* harmony import */ var _EdgeVertex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./EdgeVertex */ "./src/PolygonDraw/EdgeVertex.tsx");
/* harmony import */ var _PolygonVertex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PolygonVertex */ "./src/PolygonDraw/PolygonVertex.tsx");
/* harmony import */ var _BoundaryPolygon__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./BoundaryPolygon */ "./src/PolygonDraw/BoundaryPolygon.tsx");
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Polygon */ "./src/PolygonDraw/Polygon.tsx");
/* harmony import */ var _MapInner__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./MapInner */ "./src/PolygonDraw/MapInner.tsx");
/* harmony import */ var _ActionBar_EdgeConstraintsBar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../ActionBar/EdgeConstraintsBar */ "./src/ActionBar/EdgeConstraintsBar.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");








//import { TileLayer } from '../leaflet/TileLayer';












const edgeConstraints = {
  0: 'horizontal',
  // Edge with index 0 has a horizontal constraint
  1: 'vertical' // Edge with index 1 has a vertical constraint
};

class BaseMap extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {
  map = null;
  state = {
    isMovedPointInBoundary: true,
    isShiftPressed: false,
    isMoveActive: false,
    rectangleSelection: null,
    previousMouseMovePosition: undefined,
    selectedEdge: null,
    edgeRestrictions: null,
    isPenToolActive: false,
    isDrawToolActive: false,
    edgeConstraints: {},
    newPointPosition: null,
    showExportPolygonModal: false,
    showImportPolygonModal: false
  };
  static getDerivedStateFromProps(props, state) {
    return {
      ...state,
      isPenToolActive: props.polygonCoordinates.length === 0 ? true : state.isPenToolActive
    };
  }
  componentDidMount() {
    this.reframe();
    this.toggleVectorMode();
    const container = this.map?.getContainer();
    if (container) {
      container.addEventListener('keydown', this.handleKeyDown, false);
      container.addEventListener('keyup', this.handleKeyUp);
    }
  }
  componentWillUnmount() {
    const container = this.map?.getContainer();
    if (container) {
      container.removeEventListener('keydown', this.handleKeyDown, false);
      container.removeEventListener('keyup', this.handleKeyUp);
    }
  }
  getSnapshotBeforeUpdate(prevProps, prevState) {
    const reframe =
    // Reframe when the polygon loads for the first time
    prevProps.polygonCoordinates[prevProps.activePolygonIndex].length === 0 && this.props.polygonCoordinates[this.props.activePolygonIndex].length > 1 ||
    // Reframe when the boundary polygon loads for the first time
    prevProps.boundaryPolygonCoordinates !== this.props.boundaryPolygonCoordinates;
    const size = this.getSize(this.map);
    return {
      reframe,
      size
    };
  }
  componentDidUpdate(prevProps, prevState, {
    reframe,
    size
  }) {
    if (reframe) {
      this.reframe();
    }
    if (this.map && this.getSize(this.map) !== size) {
      this.map.invalidateSize();
    }
  }
  setMap = map => {
    if (map) {
      this.map = map;
      this.reframe();
      this.toggleVectorMode();
      const container = map?.getContainer();
      if (container) {
        container?.addEventListener('keydown', this.handleKeyDown, false);
        container?.addEventListener('keyup', this.handleKeyUp);
      }
    }
  };
  reframe = () => {
    const {
      polygonCoordinates,
      boundaryPolygonCoordinates,
      initialCenter,
      initialZoom
    } = this.props;
    if (polygonCoordinates[this.props.activePolygonIndex].length > 1) {
      this.reframeOnPolygon(polygonCoordinates);
    } else if (boundaryPolygonCoordinates.length > 0 && boundaryPolygonCoordinates !== _constants__WEBPACK_IMPORTED_MODULE_7__.MAP.WORLD_COORDINATES) {
      this.reframeOnPolygon(boundaryPolygonCoordinates);
    } else if (this.map) {
      this.map.setView(initialCenter, initialZoom);
    }
  };
  reframeOnPolygon = polygonCoordinates => {
    if (this.map && polygonCoordinates.length > 0) {
      const bounds = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngBoundsFromCoordinates)(lodash_flatten__WEBPACK_IMPORTED_MODULE_2___default()(polygonCoordinates));
      this.map.fitBounds(bounds);
    }
  };
  toggleVectorMode = () => {
    if (!this.props.editable) {
      return;
    }
    this.setState({
      isPenToolActive: !this.state.isPenToolActive,
      newPointPosition: null
    });
  };
  toggleDrawMode = () => {
    if (!this.props.drawable) {
      return;
    }
    this.setState({
      isPenToolActive: !this.state.isPenToolActive,
      newPointPosition: null
    });
  };
  getSize = map => {
    const container = map?.getContainer();
    return container ? `${container.clientHeight}x${container.clientWidth}` : '';
  };
  handleOnFocusClicked = () => {
    const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];
    if (activePolygon) {
      this.reframeOnPolygon(activePolygon);
    } else {
      this.reframe();
    }
  };

  ///////////////////////////////////////////////////////////////////////////
  //                          Export / Import methods                      //
  ///////////////////////////////////////////////////////////////////////////

  handleExportPolygon = serialized => {
    navigator.clipboard.writeText(serialized);
  };
  handleExportPolygonActionClicked = () => {
    this.setState({
      showExportPolygonModal: true
    });
  };
  handleExportPolygonModalClosed = () => {
    this.setState({
      showExportPolygonModal: false
    });
  };
  handleImportPolygon = coordinates => {
    this.props.setPolygon(coordinates);
    this.reframeOnPolygon(coordinates);
  };
  handleImportPolygonActionClicked = () => {
    this.setState({
      showImportPolygonModal: true
    });
  };
  handleImportPolygonModalClosed = () => {
    this.setState({
      showImportPolygonModal: false
    });
  };

  ///////////////////////////////////////////////////////////////////////////
  //                          Map Events methods                           //
  ///////////////////////////////////////////////////////////////////////////

  handleMapClick = event => {
    const coordinate = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createCoordinateFromLeafletLatLng)(event.latlng);
    if (this.state.isPenToolActive && !this.props.isPolygonClosed && (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.isCoordinateInPolygon)(coordinate, this.props.boundaryPolygonCoordinates)) {
      this.props.addPoint(coordinate);
    } else if (!this.state.isShiftPressed) {
      this.props.deselectAllPoints();
    }
  };
  handleMouseDownOnMap = event => {
    const coordinate = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createCoordinateFromLeafletLatLng)(event.latlng);
    if (this.state.isShiftPressed) {
      this.setState({
        rectangleSelection: {
          startPosition: coordinate,
          endPosition: coordinate,
          startTime: new Date().getTime()
        }
      });
    }
  };
  handleMouseUpOnMap = () => {
    if (this.state.rectangleSelection) {
      this.setState({
        rectangleSelection: null
      });
    }
  };
  handleMouseMoveOnMap = event => {
    const mouseCoordinate = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createCoordinateFromLeafletLatLng)(event.latlng);
    if (this.state.rectangleSelection && new Date().getTime() - this.state.rectangleSelection?.startTime >= 100) {
      const start = this.state.rectangleSelection.startPosition;
      if (start) {
        const bounds = (0,leaflet__WEBPACK_IMPORTED_MODULE_1__.latLngBounds)((0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate)(start), event.latlng);
        const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];
        if (activePolygon) {
          const pointsInsideBounds = [];
          activePolygon.forEach((point, index) => {
            if (bounds.contains((0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate)(point))) {
              pointsInsideBounds.push(index);
            }
          });
          this.props.selectPoints(pointsInsideBounds);
        }
      }
      this.setState({
        rectangleSelection: {
          ...this.state.rectangleSelection,
          endPosition: mouseCoordinate
        }
      });
    } else {
      const newPointPosition = this.state.isPenToolActive && !this.props.isPolygonClosed && (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.isCoordinateInPolygon)(mouseCoordinate, this.props.boundaryPolygonCoordinates) ? mouseCoordinate : null;
      this.setState({
        newPointPosition
      });
    }
  };
  handleMouseOutOfMap = () => this.setState({
    newPointPosition: null,
    rectangleSelection: null
  });

  ///////////////////////////////////////////////////////////////////////////
  //                           Vertex methods                              //
  ///////////////////////////////////////////////////////////////////////////

  onPolygonVertexClick = index => {
    if (index === 0 && this.props.polygonCoordinates[this.props.activePolygonIndex].length > 2 && !this.props.isPolygonClosed) {
      // Close polygon when user clicks the first point
      this.props.addPoint({
        ...this.props.polygonCoordinates[this.props.activePolygonIndex][0]
      });
    } else if (this.state.isShiftPressed) {
      if (this.props.selection.has(index)) {
        this.props.removePointFromSelection(index);
      } else {
        this.props.addPointsToSelection([index]);
      }
    } else {
      this.props.selectPoints([index]);
    }
  };
  startVertexMove = latLng => {
    if (!this.state.isMoveActive) {
      this.setState({
        isMoveActive: true,
        previousMouseMovePosition: (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createCoordinateFromLeafletLatLng)(latLng)
      });
    }
  };
  onPolygonVertexDragStart = (latLng, index) => {
    if (!this.props.selection.has(index)) {
      if (this.state.isShiftPressed) {
        this.props.addPointsToSelection([index]);
      } else {
        this.props.selectPoints([index]);
      }
    }
    this.startVertexMove(latLng);
  };
  updateVertexPosition = latLng => {
    if (this.state.isMoveActive && this.state.previousMouseMovePosition) {
      const coordinate = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createCoordinateFromLeafletLatLng)(latLng);
      const moveVector = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.subtractCoordinates)(coordinate, this.state.previousMouseMovePosition);
      const nextCoordinates = Array.from(this.props.selection).map(i => this.props.polygonCoordinates[this.props.activePolygonIndex][i]).map(coord => (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.addCoordinates)(coord, moveVector));
      const inBoundary = nextCoordinates.every(nextCoordinate => (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.isCoordinateInPolygon)(nextCoordinate, this.props.boundaryPolygonCoordinates));
      if (inBoundary) {
        this.props.moveSelectedPoints(moveVector);
        this.setState({
          previousMouseMovePosition: coordinate,
          isMovedPointInBoundary: true
        });
      } else {
        this.setState({
          isMovedPointInBoundary: false
        });
      }
    }
  };
  endVertexMove = () => {
    if (this.state.isMoveActive) {
      this.setState({
        isMoveActive: false,
        previousMouseMovePosition: undefined,
        isMovedPointInBoundary: true
      });
    }
  };
  handleEdgeClick = (coordinate, index) => {
    if (this.state.selectedEdge === index) {
      // If the same edge is clicked, add a vertex in the middle of the edge.
      this.handleAddVertexInMiddleOfEdge();
    } else {
      // Otherwise, just set the clicked edge as the selected edge.
      this.setState({
        selectedEdge: index
      });
    }
  };
  handleAddVertexInMiddleOfEdge = () => {
    if (this.state.selectedEdge === null) {
      console.error("No edge selected to add a vertex.");
      return;
    }
    const activePolygon = this.props.polygonCoordinates[this.props.activePolygonIndex];
    const startPoint = activePolygon[this.state.selectedEdge];
    const endPoint = activePolygon[(this.state.selectedEdge + 1) % activePolygon.length];
    const midpoint = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.getMidPoint)(startPoint, endPoint);
    this.props.addPointToEdge(midpoint, this.state.selectedEdge);
    this.setState({
      selectedEdge: null
    });
  };
  handleSetHorizontal = () => {
    this.setState({
      edgeRestrictions: 'horizontal'
    });
  };
  handleSetVertical = () => {
    this.setState({
      edgeRestrictions: 'vertical'
    });
  };

  ///////////////////////////////////////////////////////////////////////////
  //                      Keyboard handling methods                        //
  ///////////////////////////////////////////////////////////////////////////

  handleKeyDown = e => {
    e.preventDefault();
    switch (e.key) {
      case 'Escape':
        this.props.deselectAllPoints();
        break;
      case 'Backspace':
        this.props.deletePolygonPoints();
        break;
      case 'Shift':
        this.setState({
          isShiftPressed: true
        });
        break;
      case 'p':
        this.toggleVectorMode();
        break;
      case 'd':
        if (this.props.editable) {
          this.props.deselectAllPoints();
        }
        break;
      case 'a':
        if (this.props.editable) {
          this.props.selectAllPoints();
        }
        break;
      case 'f':
        this.reframe();
        break;
      case 'z':
        if (e.metaKey && e.shiftKey) {
          this.props.onRedo();
        } else if (e.metaKey) {
          this.props.onUndo();
        }
        break;
    }
  };
  handleKeyUp = e => {
    switch (e.key) {
      case 'Shift':
        this.setState({
          isShiftPressed: false
        });
        break;
    }
  };

  ///////////////////////////////////////////////////////////////////////////
  //                           Render methods                              //
  ///////////////////////////////////////////////////////////////////////////

  renderPolygonVertex = (coordinate, index) => {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_PolygonVertex__WEBPACK_IMPORTED_MODULE_11__.PolygonVertex, {
      coordinate: coordinate,
      isSelected: this.props.selection.has(index),
      index: index,
      onClick: this.onPolygonVertexClick,
      onDragStart: this.onPolygonVertexDragStart,
      onDrag: this.updateVertexPosition,
      onDragEnd: this.endVertexMove
    }, index);
  };
  renderActivePolygonPoints = () => {
    return this.props.polygonCoordinates[this.props.activePolygonIndex].map(this.renderPolygonVertex);
  };
  renderVertexEdge = (coordinate, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_EdgeVertex__WEBPACK_IMPORTED_MODULE_10__.EdgeVertex, {
    index: index,
    coordinate: coordinate,
    onClick: this.props.addPointToEdge
  }, index);
  // the olde version with not fincvtionalitu to work with the adding the vertexe to the middle of the
  // renderPolygonEdges = () => {
  //     return getPolygonEdges(this.props.polygonCoordinates[this.props.activePolygonIndex]).map(this.renderVertexEdge);
  // };

  // the new wersion of the renderVertexEdge
  renderPolygonEdges = () => {
    return (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.getPolygonEdges)(this.props.polygonCoordinates[this.props.activePolygonIndex]).map((coordinate, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_EdgeVertex__WEBPACK_IMPORTED_MODULE_10__.EdgeVertex, {
      index: index,
      coordinate: coordinate,
      onClick: this.handleEdgeClick
    }, index));
  };
  renderInactivePolygons = () => {
    const activePolygonIsClosed = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.isPolygonClosed)(this.props.polygonCoordinates[this.props.activePolygonIndex]);
    return this.props.polygonCoordinates.map((coordinates, index) => {
      const eventHandler = {
        onClick: () => this.props.onClick && this.props.onClick(index),
        onMouseEnter: () => this.props.onMouseEnter && this.props.onMouseEnter(index),
        onMouseLeave: () => this.props.onMouseLeave && this.props.onMouseLeave(index)
      };
      return index === this.props.activePolygonIndex ? null : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon, {
        coordinates: coordinates,
        isActive: false,
        isHighlighted: index === this.props.highlightedPolygonIndex,
        ...(activePolygonIsClosed ? eventHandler : {})
      }, `${index}-${coordinates.reduce((acc, cur) => acc + cur.latitude + cur.longitude, 0)}`);
    });
  };
  renderActivePolygon = () => {
    const coordinates = this.props.polygonCoordinates[this.props.activePolygonIndex];
    const index = this.props.activePolygonIndex;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_Polygon__WEBPACK_IMPORTED_MODULE_13__.Polygon, {
      coordinates: coordinates,
      isActive: true,
      isHighlighted: false,
      onClick: () => this.props.onClick && this.props.onClick(index),
      onMouseEnter: () => this.props.onMouseEnter && this.props.onMouseEnter(index),
      onMouseLeave: () => this.props.onMouseLeave && this.props.onMouseLeave(index)
    });
  };
  renderPolyline = () => {
    const {
      newPointPosition
    } = this.state;
    const polygon = this.props.polygonCoordinates[this.props.activePolygonIndex].map(_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate);
    if (polygon.length === 0) {
      return null;
    }
    const newPath = [polygon[polygon.length - 1]];
    if (newPointPosition) {
      newPath.push((0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate)(newPointPosition));
    }
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(react_leaflet__WEBPACK_IMPORTED_MODULE_16__.Polyline, {
        positions: polygon,
        color: _constants__WEBPACK_IMPORTED_MODULE_7__.MAP.POLYGON_ACTIVE_COLOR,
        interactive: false
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(react_leaflet__WEBPACK_IMPORTED_MODULE_16__.Polyline, {
        positions: newPath,
        color: _constants__WEBPACK_IMPORTED_MODULE_7__.MAP.POLYGON_ACTIVE_COLOR,
        dashArray: "2 12",
        interactive: false
      })]
    });
  };
  renderSelectionRectangle = () => {
    if (this.state.rectangleSelection) {
      const bounds = (0,leaflet__WEBPACK_IMPORTED_MODULE_1__.latLngBounds)((0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate)(this.state.rectangleSelection.startPosition), (0,_helpers__WEBPACK_IMPORTED_MODULE_3__.createLeafletLatLngFromCoordinate)(this.state.rectangleSelection.endPosition));
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(react_leaflet__WEBPACK_IMPORTED_MODULE_17__.Rectangle, {
        color: _constants__WEBPACK_IMPORTED_MODULE_7__.MAP.RECTANGLE_SELECTION_COLOR,
        fillColor: _constants__WEBPACK_IMPORTED_MODULE_7__.MAP.RECTANGLE_SELECTION_COLOR,
        bounds: bounds
      });
    }
    return null;
  };
  render() {
    const {
      editable,
      drawable,
      selection,
      initialZoom,
      initialCenter
    } = this.props;
    const {
      newPointPosition,
      isPenToolActive,
      isDrawToolActive
    } = this.state;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_leaflet_Map__WEBPACK_IMPORTED_MODULE_8__.Container, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_leaflet_Map__WEBPACK_IMPORTED_MODULE_8__.Map, {
        fadeAnimation: true,
        trackResize: true,
        zoomControl: false,
        ref: this.setMap,
        center: initialCenter,
        zoom: initialZoom,
        zoomDelta: 2,
        zoomSnap: 1.5,
        boxZoom: false,
        drawCursor: !!newPointPosition,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_BoundaryPolygon__WEBPACK_IMPORTED_MODULE_12__.BoundaryPolygon, {
          coordinates: this.props.boundaryPolygonCoordinates,
          hasError: !this.state.isMovedPointInBoundary
        }), this.props.isPolygonClosed ? this.renderActivePolygon() : this.renderPolyline(), this.renderInactivePolygons(), editable && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(react_leaflet__WEBPACK_IMPORTED_MODULE_18__.Pane, {
          name: "Polygon points",
          children: [this.renderActivePolygonPoints(), this.props.isPolygonClosed && isPenToolActive && this.renderPolygonEdges()]
        }), this.state.rectangleSelection && this.renderSelectionRectangle(), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_MapInner__WEBPACK_IMPORTED_MODULE_19__["default"], {
          onClick: this.handleMapClick,
          onMouseOut: this.handleMouseOutOfMap,
          onMouseMove: this.handleMouseMoveOnMap,
          onMouseDown: this.handleMouseDownOnMap,
          onMouseUp: this.handleMouseUpOnMap
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_ActionBar_ActionBar__WEBPACK_IMPORTED_MODULE_9__.ActionBar, {
        editable: editable,
        drawable: drawable,
        isVectorModeEnabled: isPenToolActive,
        isDrawModeEnabled: isDrawToolActive,
        onDelete: this.props.deletePolygonPoints,
        onFocus: this.handleOnFocusClicked,
        onAddVertex: this.handleAddVertexInMiddleOfEdge,
        onEnableDrawMode: this.toggleDrawMode,
        onEnableVectorMode: this.toggleVectorMode,
        deleteInactive: selection.size === 0,
        onExport: this.handleExportPolygonActionClicked,
        onImport: this.handleImportPolygonActionClicked
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_ActionBar_EdgeConstraintsBar__WEBPACK_IMPORTED_MODULE_14__.EdgeConstraintsBar, {
        onSetHorizontal: this.handleSetHorizontal,
        onSetVertical: this.handleSetVertical
      }), this.state.showExportPolygonModal && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_common_components_Modal__WEBPACK_IMPORTED_MODULE_4__.Modal, {
        onClose: this.handleExportPolygonModalClosed,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_conversion_ExportPolygonForm__WEBPACK_IMPORTED_MODULE_5__.ExportPolygonForm, {
          polygon: this.props.polygonCoordinates[this.props.activePolygonIndex],
          onSubmit: this.handleExportPolygon
        })
      }), this.state.showImportPolygonModal && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_common_components_Modal__WEBPACK_IMPORTED_MODULE_4__.Modal, {
        onClose: this.handleImportPolygonModalClosed,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_conversion_ImportPolygonForm__WEBPACK_IMPORTED_MODULE_6__.ImportPolygonForm, {
          onSubmit: this.handleImportPolygon
        })
      })]
    });
  }
}
BaseMap.displayName = "BaseMap";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(BaseMap));
try {
    // @ts-ignore
    BaseMap.displayName = "BaseMap";
    // @ts-ignore
    BaseMap.__docgenInfo = { "description": "", "displayName": "BaseMap", "props": { "activePolygonIndex": { "defaultValue": null, "description": "activePolygonIndex is the index of the polygon that is currently available for editing", "name": "activePolygonIndex", "required": true, "type": { "name": "number" } }, "highlightedPolygonIndex": { "defaultValue": null, "description": "", "name": "highlightedPolygonIndex", "required": false, "type": { "name": "number" } }, "polygonCoordinates": { "defaultValue": null, "description": "", "name": "polygonCoordinates", "required": true, "type": { "name": "Coordinate[][]" } }, "boundaryPolygonCoordinates": { "defaultValue": null, "description": "", "name": "boundaryPolygonCoordinates", "required": true, "type": { "name": "Coordinate[]" } }, "selection": { "defaultValue": null, "description": "", "name": "selection", "required": true, "type": { "name": "Set<number>" } }, "editable": { "defaultValue": null, "description": "", "name": "editable", "required": true, "type": { "name": "boolean" } }, "drawable": { "defaultValue": null, "description": "", "name": "drawable", "required": true, "type": { "name": "boolean" } }, "initialCenter": { "defaultValue": null, "description": "", "name": "initialCenter", "required": true, "type": { "name": "LatLngTuple" } }, "initialZoom": { "defaultValue": null, "description": "", "name": "initialZoom", "required": true, "type": { "name": "number" } }, "isPolygonClosed": { "defaultValue": null, "description": "", "name": "isPolygonClosed", "required": true, "type": { "name": "boolean" } }, "onClick": { "defaultValue": null, "description": "", "name": "onClick", "required": false, "type": { "name": "((index: number) => void)" } }, "onMouseEnter": { "defaultValue": null, "description": "", "name": "onMouseEnter", "required": false, "type": { "name": "((index: number) => void)" } }, "onMouseLeave": { "defaultValue": null, "description": "", "name": "onMouseLeave", "required": false, "type": { "name": "((index: number) => void)" } }, "addPoint": { "defaultValue": null, "description": "", "name": "addPoint", "required": true, "type": { "name": "(coord: Coordinate) => void" } }, "addPointToEdge": { "defaultValue": null, "description": "", "name": "addPointToEdge", "required": true, "type": { "name": "(coordinate: Coordinate, index: number) => void" } }, "deselectAllPoints": { "defaultValue": null, "description": "", "name": "deselectAllPoints", "required": true, "type": { "name": "() => void" } }, "removePointFromSelection": { "defaultValue": null, "description": "", "name": "removePointFromSelection", "required": true, "type": { "name": "(index: number) => void" } }, "addPointsToSelection": { "defaultValue": null, "description": "", "name": "addPointsToSelection", "required": true, "type": { "name": "(indices: number[]) => void" } }, "selectPoints": { "defaultValue": null, "description": "", "name": "selectPoints", "required": true, "type": { "name": "(indices: number[]) => void" } }, "moveSelectedPoints": { "defaultValue": null, "description": "", "name": "moveSelectedPoints", "required": true, "type": { "name": "(newPosition: Coordinate) => void" } }, "deletePolygonPoints": { "defaultValue": null, "description": "", "name": "deletePolygonPoints", "required": true, "type": { "name": "() => void" } }, "selectAllPoints": { "defaultValue": null, "description": "", "name": "selectAllPoints", "required": true, "type": { "name": "() => void" } }, "setPolygon": { "defaultValue": null, "description": "", "name": "setPolygon", "required": true, "type": { "name": "(polygon: Coordinate[]) => void" } }, "onUndo": { "defaultValue": null, "description": "", "name": "onUndo", "required": true, "type": { "name": "() => void" } }, "onRedo": { "defaultValue": null, "description": "", "name": "onRedo", "required": true, "type": { "name": "() => void" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/PolygonDraw/Map.tsx#BaseMap"] = { docgenInfo: BaseMap.__docgenInfo, name: "BaseMap", path: "src/PolygonDraw/Map.tsx#BaseMap" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ })

});
//# sourceMappingURL=PolygonDraw-stories.92f0641ad6c9b14e2053.hot-update.js.map